=============== 前 30 页代码开始 ===============
{
  "extends": [
    "next/core-web-vitals",
    "next/typescript"
  ]
}
"use server";
/**
 * 广告管理 Server Actions
 * 实现双端同步：Supabase (国际版) + CloudBase (国内版)
 */
import { supabaseAdmin } from "@/lib/supabaseAdmin";
import { CloudBaseConnector } from "@/lib/cloudbase/connector";
import { getAdminSession } from "@/utils/session";
import { revalidatePath } from "next/cache";
// 广告位置类型
export type AdPosition = "top" | "bottom" | "left" | "right" | "sidebar" | "bottom-left" | "bottom-right";
// 广告类型定义
export interface Advertisement {
  id: string;
  title: string;
  position: AdPosition;
  media_type: "image" | "video";
  media_url: string;
  target_url: string | null;
  is_active: boolean;
  priority: number;
  created_at: string;
  source: "supabase" | "cloudbase" | "both"; // 数据来源
  file_size?: number; // 文件大小（字节）
}
export interface CreateAdResult {
  success: boolean;
  error?: string;
  data?: Advertisement;
}
export interface UpdateAdResult {
  success: boolean;
  error?: string;
}
export interface DeleteAdResult {
  success: boolean;
  error?: string;
}
export interface ListAdsResult {
  success: boolean;
  error?: string;
  data?: Advertisement[];
}
export interface StorageFile {
  name: string;
  url: string;
  size?: number;
  lastModified?: string;
  source: "supabase" | "cloudbase";
  fileId?: string; // CloudBase fileID，用于删除操作
  adId?: string; // 关联的广告 ID（CloudBase）
}
export interface ListFilesResult {
  success: boolean;
  error?: string;
  supabaseFiles?: StorageFile[];
  cloudbaseFiles?: StorageFile[];
}
/**
 * 验证管理员权限
 */
async function requireAdmin() {
  const session = await getAdminSession();
  if (!session) {
    throw new Error("未授权访问");
  }
  return session;
}
/**
 * 获取 CloudBase 客户端
 */
async function getCloudBase() {
  const connector = new CloudBaseConnector();
  await connector.initialize();
  return {
    db: connector.getClient(),
    app: connector.getApp(),
  };
}
/**
 * 上传文件到 Supabase Storage
 */
async function uploadToSupabase(
  file: File,
  fileName: string
): Promise<string | null> {
  if (!supabaseAdmin) return null;
  try {
    const buffer = Buffer.from(await file.arrayBuffer());
    const filePath = `${fileName}`;
    const { error } = await supabaseAdmin.storage
      .from("ads")
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true,
      });
    if (error) {
      console.error("Supabase upload error:", error);
      return null;
    }
    // 获取公开 URL
    const { data: urlData } = supabaseAdmin.storage
      .from("ads")
      .getPublicUrl(filePath);
    return urlData.publicUrl;
  } catch (err) {
    console.error("Supabase upload exception:", err);
    return null;
  }
}
/**
 * 上传文件到 CloudBase Storage
 * 返回 fileID（而不是临时 URL），便于后续获取新的临时 URL
 */
async function uploadToCloudBase(
  file: File,
  fileName: string
): Promise<string | null> {
  try {
    const { app } = await getCloudBase();
    const buffer = Buffer.from(await file.arrayBuffer());
    const cloudPath = `ads/${fileName}`;
    console.log("CloudBase uploading to:", cloudPath);
    console.log("CloudBase env:", process.env.WECHAT_CLOUDBASE_ID);
    // Node SDK 使用 uploadFile 方法
    const uploadResult = await app.uploadFile({
      cloudPath,
      fileContent: buffer,
    });
    console.log("CloudBase upload result:", JSON.stringify(uploadResult, null, 2));
    if (!uploadResult.fileID) {
      console.error("CloudBase upload failed: no fileID returned");
      return null;
    }
    console.log("CloudBase upload success, fileID:", uploadResult.fileID);
    // 返回 fileID
    return uploadResult.fileID;
  } catch (err) {
    console.error("CloudBase upload exception:", err);
    return null;
  }
}
/**
 * 创建广告 - 支持选择上传目标
 * @param formData 包含 uploadTarget: "both" | "supabase" | "cloudbase"
 */
export async function createAdvertisement(
  formData: FormData
): Promise<CreateAdResult> {
  try {
    await requireAdmin();
    const title = formData.get("title") as string;
    const position = formData.get("position") as AdPosition;
    const mediaType = formData.get("mediaType") as "image" | "video";
    const targetUrl = formData.get("targetUrl") as string;
    const priority = parseInt(formData.get("priority") as string) || 0;
    const isActive = formData.get("isActive") === "true";
    const file = formData.get("file") as File;
    const uploadTarget = (formData.get("uploadTarget") as string) || "both";
    if (!title || !position || !mediaType) {
      return { success: false, error: "请填写必要字段" };
    }
    if (!file || file.size === 0) {
      return { success: false, error: "请上传媒体文件" };
    }
    // 生成唯一文件名
    const ext = file.name.split(".").pop();
    const fileName = `${Date.now()}-${Math.random().toString(36).slice(2)}.${ext}`;
    // 根据选择上传到对应存储
    let supabaseUrl: string | null = null;
    let cloudbaseUrl: string | null = null;
    if (uploadTarget === "both" || uploadTarget === "supabase") {
      supabaseUrl = await uploadToSupabase(file, fileName);
      if (!supabaseUrl && (uploadTarget === "supabase" || uploadTarget === "both")) {
        return { success: false, error: "上传到 Supabase 失败" };
      }
    }
    if (uploadTarget === "both" || uploadTarget === "cloudbase") {
      cloudbaseUrl = await uploadToCloudBase(file, fileName);
      if (!cloudbaseUrl && uploadTarget === "cloudbase") {
        return { success: false, error: "上传到 CloudBase 失败" };
      }
    }
    // 生成 UUID
    const id = crypto.randomUUID();
    // 根据选择写入对应数据库
    const results: { supabase?: { error: unknown }; cloudbase?: { error: unknown } } = {};
    if ((uploadTarget === "both" || uploadTarget === "supabase") && supabaseUrl) {
      const supabaseResult = supabaseAdmin
        ? await supabaseAdmin.from("advertisements").insert({
            id,
            title,
            position,
            media_type: mediaType,
            media_url: supabaseUrl,
            target_url: targetUrl || null,
            is_active: isActive,
            priority,
            file_size: file.size, // 保存文件大小
          })
        : { error: new Error("Supabase not configured") };
      results.supabase = supabaseResult;
      if (supabaseResult.error) {
        console.error("Supabase insert error:", supabaseResult.error);
        if (uploadTarget === "supabase") {
          return { success: false, error: "保存到 Supabase 失败" };
        }
      }
    }
    if ((uploadTarget === "both" || uploadTarget === "cloudbase") && cloudbaseUrl) {
      try {
        const { db } = await getCloudBase();
        await db.collection("advertisements").add({
          _id: id,
          title,
          position,
          media_type: mediaType,
          media_url: cloudbaseUrl,
          target_url: targetUrl || null,
          is_active: isActive,
          priority,
          created_at: new Date().toISOString(),
          file_size: file.size, // 保存文件大小
        });
        results.cloudbase = { error: null };
      } catch (err) {
        console.error("CloudBase insert error:", err);
        results.cloudbase = { error: err };
        if (uploadTarget === "cloudbase") {
          return { success: false, error: "保存到 CloudBase 失败" };
        }
      }
    }
    // 检查是否至少有一个成功
    const supabaseSuccess = !results.supabase?.error;
    const cloudbaseSuccess = !results.cloudbase?.error;
    if (uploadTarget === "both" && !supabaseSuccess && !cloudbaseSuccess) {
      return { success: false, error: "保存到数据库失败" };
    }
    revalidatePath("/admin/ads");
    // 确定数据源
    let source: "supabase" | "cloudbase" | "both" = "both";
    if (uploadTarget === "supabase") {
      source = "supabase";
    } else if (uploadTarget === "cloudbase") {
      source = "cloudbase";
    }
    return {
      success: true,
      data: {
        id,
        title,
        position,
        media_type: mediaType,
        media_url: supabaseUrl || cloudbaseUrl || "",
        target_url: targetUrl || null,
        is_active: isActive,
        priority,
        created_at: new Date().toISOString(),
        source,
        file_size: file.size,
      },
    };
  } catch (err) {
    console.error("Create advertisement error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "创建广告失败",
    };
  }
}
/**
 * 获取广告列表（合并 Supabase 和 CloudBase）
 */
export async function listAdvertisements(): Promise<ListAdsResult> {
  try {
    await requireAdmin();
    const adsMap = new Map<string, Advertisement>();
    // 从 Supabase 获取
    if (supabaseAdmin) {
      try {
        const { data, error } = await supabaseAdmin
          .from("advertisements")
          .select("*")
          .order("priority", { ascending: false })
          .order("created_at", { ascending: false });
        if (!error && data) {
          // 先获取 Storage 中的文件列表以获取文件大小
          let storageFiles: { name: string; metadata?: { size?: number } }[] = [];
          try {
            const { data: files } = await supabaseAdmin.storage
              .from("ads")
              .list("", { limit: 1000 });
            storageFiles = files || [];
          } catch (storageErr) {
            console.warn("Get storage files warning:", storageErr);
          }
          // 创建文件名到大小的映射
          const fileSizeMap = new Map<string, number>();
          for (const file of storageFiles) {
            if (file.metadata?.size) {
              fileSizeMap.set(file.name, file.metadata.size);
            }
          }
          for (const ad of data) {
            let fileSize = ad.file_size;
            // 如果数据库中没有 file_size，尝试从 Storage 文件列表获取
            if (!fileSize && ad.media_url) {
              try {
                // 从 URL 提取文件名
                const urlParts = ad.media_url.split("/ads/");
                if (urlParts.length > 1) {
                  const fileName = decodeURIComponent(urlParts[1].split("?")[0]);
                  fileSize = fileSizeMap.get(fileName);
                }
              } catch {
                // 忽略解析错误
              }
            }
            adsMap.set(ad.id, {
              ...ad,
              file_size: fileSize,
              source: "supabase" as const,
            });
          }
        }
      } catch (err) {
        console.warn("Supabase list warning:", err);
      }
    }
    // 从 CloudBase 获取
    try {
      const connector = new CloudBaseConnector();
      await connector.initialize();
      const db = connector.getClient();
      const app = connector.getApp();
      const { data } = await db
        .collection("advertisements")
        .orderBy("priority", "desc")
        .orderBy("created_at", "desc")
        .get();
      console.log("CloudBase ads list count:", data?.length || 0);
      if (data && Array.isArray(data)) {
        // 收集需要获取临时 URL 的 fileID
        const cloudbaseAds: { ad: any; fileId: string }[] = [];
        for (const ad of data) {
          const id = ad._id || ad.id;
          let fileId: string | null = null;
          // 检查 media_url 是否是 fileID 格式
          if (ad.media_url && ad.media_url.startsWith("cloud://")) {
            fileId = ad.media_url;
            console.log(`Ad ${id} has fileID format: ${fileId}`);
          } else {
            console.log(`Ad ${id} has URL format: ${ad.media_url}`);
          }
          if (adsMap.has(id)) {
            // 两边都有，标记为 both
            const existing = adsMap.get(id)!;
            adsMap.set(id, { ...existing, source: "both" });
          } else {
            // 只在 CloudBase 有，暂时使用原 URL
            adsMap.set(id, {
              id,
              title: ad.title,
              position: ad.position,
              media_type: ad.media_type,
              media_url: ad.media_url,
              target_url: ad.target_url,
              is_active: ad.is_active,
              priority: ad.priority,
              created_at: ad.created_at,
              source: "cloudbase" as const,
              file_size: ad.file_size,
            });
            if (fileId) {
              cloudbaseAds.push({ ad: { ...ad, id }, fileId });
            }
          }
        }
        // 批量获取 CloudBase 文件的临时 URL
        if (cloudbaseAds.length > 0) {
          console.log("Getting temp URLs for", cloudbaseAds.length, "CloudBase files");
          try {
            const fileIds = cloudbaseAds.map((item) => item.fileId);
            const urlResult = await app.getTempFileURL({
              fileList: fileIds,
            });
            console.log("getTempFileURL result:", JSON.stringify(urlResult, null, 2));
            if (urlResult.fileList && Array.isArray(urlResult.fileList)) {
              // 创建 fileID -> tempURL 映射
              const urlMap = new Map<string, string>();
              for (const fileInfo of urlResult.fileList) {
                // CloudBase Node SDK 返回 code: "SUCCESS" 表示成功，而不是 status === 0
                if (fileInfo.tempFileURL && fileInfo.code === "SUCCESS") {
                  urlMap.set(fileInfo.fileID, fileInfo.tempFileURL);
                  console.log(`Got temp URL for ${fileInfo.fileID}`);
                } else {
                  console.log(`Failed to get temp URL for ${fileInfo.fileID}, code: ${fileInfo.code}`);
                }
              }
              // 更新 adsMap 中的 media_url
              for (const { ad, fileId } of cloudbaseAds) {
                const tempUrl = urlMap.get(fileId);
                if (tempUrl) {
                  const existing = adsMap.get(ad.id);
                  if (existing) {
                    adsMap.set(ad.id, { ...existing, media_url: tempUrl });
                  }
                }
              }
            }
          } catch (urlErr) {
            console.error("CloudBase getTempFileURL error:", urlErr);
            // 获取失败，保持原 URL
          }
        }
      }
    } catch (err) {
      console.error("CloudBase list error:", err);
    }
    // 转换为数组并排序
    const ads = Array.from(adsMap.values()).sort((a, b) => {
      if (b.priority !== a.priority) return b.priority - a.priority;
      return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    });
    return { success: true, data: ads };
  } catch (err) {
    console.error("List advertisements error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "获取广告列表失败",
    };
  }
}
/**
 * 更新广告 - 双端同步
 */
export async function updateAdvertisement(
  id: string,
  formData: FormData
): Promise<UpdateAdResult> {
  try {
    await requireAdmin();
    const title = formData.get("title") as string;
    const targetUrl = formData.get("targetUrl") as string;
    const priority = parseInt(formData.get("priority") as string) || 0;
    const isActive = formData.get("isActive") === "true";
    const updates = {
      title,
      target_url: targetUrl || null,
      priority,
      is_active: isActive,
    };
    // 并发更新两个数据库
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin.from("advertisements").update(updates).eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("advertisements").doc(id).update(updates);
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase update error:", supabaseResult.error);
      return { success: false, error: "更新失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase update warning:", cloudbaseResult.error);
    }
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("Update advertisement error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "更新广告失败",
    };
  }
}
/**
 * 切换广告状态（上架/下架）- 双端同步
 */
export async function toggleAdvertisementStatus(
  id: string,
  isActive: boolean
): Promise<UpdateAdResult> {
  try {
    await requireAdmin();
    // 并发更新两个数据库
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin
          .from("advertisements")
          .update({ is_active: isActive })
          .eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("advertisements").doc(id).update({ is_active: isActive });
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase toggle error:", supabaseResult.error);
      return { success: false, error: "切换状态失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase toggle warning:", cloudbaseResult.error);
    }
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("Toggle advertisement error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "切换状态失败",
    };
  }
}
/**
 * 删除广告 - 双端同步（硬删除）
 */
export async function deleteAdvertisement(id: string): Promise<DeleteAdResult> {
  try {
    await requireAdmin();
    // 先获取广告信息以便删除存储文件
    let mediaUrl: string | null = null;
    if (supabaseAdmin) {
      const { data } = await supabaseAdmin
        .from("advertisements")
        .select("media_url")
        .eq("id", id)
        .single();
      mediaUrl = data?.media_url;
    }
    // 并发删除两个数据库的记录
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin.from("advertisements").delete().eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("advertisements").doc(id).remove();
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase delete error:", supabaseResult.error);
      return { success: false, error: "删除失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase delete warning:", cloudbaseResult.error);
    }
    // 尝试删除存储文件（可选，不影响主流程）
    if (mediaUrl && supabaseAdmin) {
      try {
        // 从 URL 提取文件路径
        const urlParts = mediaUrl.split("/ads/");
        if (urlParts.length > 1) {
          const fileName = urlParts[1].split("?")[0];
          await supabaseAdmin.storage.from("ads").remove([fileName]);
        }
      } catch (err) {
        console.warn("Delete storage file warning:", err);
      }
    }
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("Delete advertisement error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "删除广告失败",
    };
  }
}
/**
 * 列出存储文件 - 两个云存储
 */
export async function listStorageFiles(): Promise<ListFilesResult> {
  try {
    await requireAdmin();
    const supabaseFiles: StorageFile[] = [];
    const cloudbaseFiles: StorageFile[] = [];
    // 获取 Supabase Storage 文件
    if (supabaseAdmin) {
      try {
        const { data, error } = await supabaseAdmin.storage
          .from("ads")
          .list("", { limit: 100 });
        if (!error && data) {
          for (const file of data) {
            const { data: urlData } = supabaseAdmin.storage
              .from("ads")
              .getPublicUrl(file.name);
            supabaseFiles.push({
              name: file.name,
              url: urlData.publicUrl,
              size: file.metadata?.size,
              lastModified: file.updated_at,
              source: "supabase",
            });
          }
        }
      } catch (err) {
        console.warn("List Supabase files warning:", err);
      }
    }
    // 获取 CloudBase Storage 文件
    try {
      // 从数据库获取广告记录
      const connector = new CloudBaseConnector();
      await connector.initialize();
      const db = connector.getClient();
      const app = connector.getApp();
      const { data } = await db.collection("advertisements").get();
      console.log("CloudBase advertisements count:", data?.length || 0);
      if (data && Array.isArray(data)) {
        // 收集所有 fileID（仅处理 cloud:// 格式的）
        const fileIdList: string[] = [];
        const adMap: Map<string, { ad: any; fileName: string }> = new Map();
        for (const ad of data) {
          if (ad.media_url) {
            console.log("Processing ad media_url:", ad.media_url);
            let fileId: string | null = null;
            let fileName: string;
            if (ad.media_url.startsWith("cloud://")) {
              // 已经是 fileID 格式（新上传的文件）
              fileId = ad.media_url;
              // 从 fileID 提取文件名: cloud://env.xxx/ads/filename.ext
              const pathParts = ad.media_url.split("/");
              fileName = pathParts[pathParts.length - 1] || ad._id;
            } else {
              // 旧的临时 URL 格式，直接使用原 URL 显示
              const urlParts = ad.media_url.split("/");
              fileName = urlParts[urlParts.length - 1]?.split("?")[0] || ad._id;
              // 对于旧 URL，直接添加到结果（不尝试获取新临时 URL）
              cloudbaseFiles.push({
                name: fileName,
                url: ad.media_url,
                size: ad.file_size, // 从广告记录获取文件大小
                lastModified: ad.created_at, // 使用创建时间作为修改时间
                source: "cloudbase",
                fileId: undefined,
                adId: ad._id || ad.id,
              });
              continue; // 跳过 fileID 处理
            }
            if (fileId) {
              fileIdList.push(fileId);
              adMap.set(fileId, { ad, fileName });
            }
          }
        }
        console.log("CloudBase fileIdList:", fileIdList);
        // 批量获取临时访问 URL（仅处理 cloud:// 格式的）
        if (fileIdList.length > 0) {
          try {
            const urlResult = await app.getTempFileURL({
              fileList: fileIdList,
            });
            console.log("CloudBase getTempFileURL result:", JSON.stringify(urlResult, null, 2));
            if (urlResult.fileList && Array.isArray(urlResult.fileList)) {
              for (const fileInfo of urlResult.fileList) {
                console.log("Processing fileInfo:", fileInfo);
                // 查找对应的广告记录
                const mapEntry = adMap.get(fileInfo.fileID);
                if (mapEntry) {
                  const { ad, fileName } = mapEntry;
                  // CloudBase Node SDK 返回 code: "SUCCESS" 表示成功
                  const isSuccess = fileInfo.code === "SUCCESS" && fileInfo.tempFileURL;
                  const displayUrl = isSuccess ? fileInfo.tempFileURL : ad.media_url;
                  console.log(`File ${fileName}: code=${fileInfo.code}, url=${displayUrl}`);
                  cloudbaseFiles.push({
                    name: fileName,
                    url: displayUrl,
                    size: ad.file_size, // 从广告记录获取文件大小
                    lastModified: ad.created_at, // 使用创建时间作为修改时间
                    source: "cloudbase",
                    fileId: fileInfo.fileID,
                    adId: ad._id || ad.id,
                  });
                  // 从 map 中移除已处理的
                  adMap.delete(fileInfo.fileID);
                }
              }
            }
            // 处理未能获取临时 URL 的文件（可能 fileID 不匹配）
            for (const [fileId, { ad, fileName }] of adMap) {
              console.log(`File ${fileName} not found in result, using original URL`);
              cloudbaseFiles.push({
                name: fileName,
                url: ad.media_url, // 使用原 URL
                size: ad.file_size, // 从广告记录获取文件大小
                lastModified: ad.created_at, // 使用创建时间作为修改时间
                source: "cloudbase",
                fileId: fileId,
                adId: ad._id || ad.id,
              });
            }
          } catch (urlErr) {
            console.error("CloudBase getTempFileURL error:", urlErr);
            // 如果批量获取失败，使用原 URL
            for (const [fileId, { ad, fileName }] of adMap) {
              cloudbaseFiles.push({
                name: fileName,
                url: ad.media_url,
                size: ad.file_size, // 从广告记录获取文件大小
                lastModified: ad.created_at, // 使用创建时间作为修改时间
                source: "cloudbase",
                fileId: fileId,
                adId: ad._id || ad.id,
              });
            }
          }
        }
      }
    } catch (err) {
      console.error("List CloudBase files error:", err);
    }
    return {
      success: true,
      supabaseFiles,
      cloudbaseFiles,
    };
  } catch (err) {
    console.error("List storage files error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "获取文件列表失败",
    };
  }
}
export interface FileOperationResult {
  success: boolean;
  error?: string;
}
/**
 * 删除存储文件
 * @param fileName 文件名或 fileId
 * @param source 数据源
 * @param fileId CloudBase 的 fileID（可选）
 * @param adId 关联的广告 ID（可选，用于删除 CloudBase 广告记录）
 */
export async function deleteStorageFile(
  fileName: string,
  source: "supabase" | "cloudbase",
  fileId?: string,
  adId?: string
): Promise<FileOperationResult> {
  try {
    await requireAdmin();
    if (source === "supabase") {
      if (!supabaseAdmin) {
        return { success: false, error: "Supabase 未配置" };
      }
      // 如果有关联的广告记录，先删除数据库记录
      if (adId) {
        try {
          await supabaseAdmin.from("advertisements").delete().eq("id", adId);
          console.log("Supabase ad record deleted:", adId);
        } catch (dbErr) {
          console.warn("Supabase delete ad record warning:", dbErr);
        }
      }
      const { error } = await supabaseAdmin.storage
        .from("ads")
        .remove([fileName]);
      if (error) {
        console.error("Supabase delete file error:", error);
        return { success: false, error: "删除文件失败" };
      }
    } else if (source === "cloudbase") {
      try {
        const connector = new CloudBaseConnector();
        await connector.initialize();
        const db = connector.getClient();
        const app = connector.getApp();
        // 如果提供了 adId，先删除广告记录
        if (adId) {
          try {
            await db.collection("advertisements").doc(adId).remove();
            console.log("CloudBase ad record deleted:", adId);
          } catch (dbErr) {
            console.warn("CloudBase delete ad record warning:", dbErr);
          }
        }
        // 尝试删除存储文件（仅当有有效的 fileId 时）
        if (fileId && fileId.startsWith("cloud://")) {
          try {
            await app.deleteFile({ fileList: [fileId] });
            console.log("CloudBase file deleted:", fileId);
          } catch (fileErr) {
            // 文件删除失败不影响整体操作，因为广告记录可能已删除
            console.warn("CloudBase delete file warning:", fileErr);
          }
        } else {
          console.log("No valid CloudBase fileId provided, skipping file deletion");
        }
      } catch (err) {
        console.error("CloudBase delete error:", err);
        return { success: false, error: "删除 CloudBase 文件失败" };
      }
    }
    revalidatePath("/admin/files");
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("Delete storage file error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "删除文件失败",
    };
  }
}
/**
 * 重命名存储文件（Supabase）
 * 注意：Supabase 不支持直接重命名，需要复制后删除原文件
 */
export async function renameStorageFile(
  oldName: string,
  newName: string,
  source: "supabase" | "cloudbase"
): Promise<FileOperationResult> {
  try {
    await requireAdmin();
    if (source === "supabase") {
      if (!supabaseAdmin) {
        return { success: false, error: "Supabase 未配置" };
      }
      // 下载原文件
      const { data: fileData, error: downloadError } = await supabaseAdmin.storage
        .from("ads")
        .download(oldName);
      if (downloadError || !fileData) {
        console.error("Supabase download error:", downloadError);
        return { success: false, error: "下载原文件失败" };
      }
      // 上传为新文件名
      const buffer = Buffer.from(await fileData.arrayBuffer());
      const { error: uploadError } = await supabaseAdmin.storage
        .from("ads")
        .upload(newName, buffer, {
          contentType: fileData.type,
          upsert: false,
        });
      if (uploadError) {
        console.error("Supabase upload error:", uploadError);
        return { success: false, error: "上传新文件失败" };
      }
      // 删除原文件
      const { error: deleteError } = await supabaseAdmin.storage
        .from("ads")
        .remove([oldName]);
      if (deleteError) {
        console.warn("Supabase delete old file warning:", deleteError);
        // 不返回错误，因为新文件已创建成功
      }
      // 更新数据库中引用该文件的广告记录
      const { data: urlData } = supabaseAdmin.storage
        .from("ads")
        .getPublicUrl(newName);
      const oldUrl = supabaseAdmin.storage.from("ads").getPublicUrl(oldName).data.publicUrl;
      await supabaseAdmin
        .from("advertisements")
        .update({ media_url: urlData.publicUrl })
        .eq("media_url", oldUrl);
    } else if (source === "cloudbase") {
      // CloudBase 重命名：下载原文件 -> 上传新文件名 -> 删除原文件 -> 更新数据库记录
      return { success: false, error: "CloudBase 暂不支持重命名文件（需要提供 fileId 和 adId）" };
    }
    revalidatePath("/admin/files");
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("Rename storage file error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "重命名文件失败",
    };
  }
}
/**
 * CloudBase 文件重命名（需要 fileId 和 adId）
 * 实现方式：下载原文件 -> 上传新文件名 -> 删除原文件 -> 更新数据库记录
 */
export async function renameCloudBaseFile(
  oldName: string,
  newName: string,
  fileId: string,
  adId: string
): Promise<FileOperationResult> {
  try {
    await requireAdmin();
    if (!fileId || !fileId.startsWith("cloud://")) {
      return { success: false, error: "无效的 CloudBase fileId" };
    }
    const connector = new CloudBaseConnector();
    await connector.initialize();
    const db = connector.getClient();
    const app = connector.getApp();
    // 1. 下载原文件
    console.log("CloudBase rename: downloading file", fileId);
    const downloadResult = await app.downloadFile({
      fileID: fileId,
    });
    if (!downloadResult.fileContent) {
      console.error("CloudBase download failed: no fileContent");
      return { success: false, error: "下载原文件失败" };
    }
    // 2. 上传为新文件名
    const newCloudPath = `ads/${newName}`;
    console.log("CloudBase rename: uploading to", newCloudPath);
    const uploadResult = await app.uploadFile({
      cloudPath: newCloudPath,
      fileContent: downloadResult.fileContent,
    });
    if (!uploadResult.fileID) {
      console.error("CloudBase upload failed: no fileID returned");
      return { success: false, error: "上传新文件失败" };
    }
    console.log("CloudBase rename: new fileID", uploadResult.fileID);
    // 3. 更新数据库记录
    try {
      await db.collection("advertisements").doc(adId).update({
        media_url: uploadResult.fileID,
      });
      console.log("CloudBase rename: database updated");
    } catch (dbErr) {
      console.error("CloudBase rename: database update failed", dbErr);
      // 尝试删除新上传的文件
      try {
        await app.deleteFile({ fileList: [uploadResult.fileID] });
      } catch {}
      return { success: false, error: "更新数据库记录失败" };
    }
    // 4. 删除原文件
    try {
      await app.deleteFile({ fileList: [fileId] });
      console.log("CloudBase rename: old file deleted");
    } catch (deleteErr) {
      // 删除失败不影响整体操作，因为新文件已创建并且数据库已更新
      console.warn("CloudBase rename: delete old file warning", deleteErr);
    }
    revalidatePath("/admin/files");
    revalidatePath("/admin/ads");
    return { success: true };
  } catch (err) {
    console.error("CloudBase rename error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "重命名文件失败",
    };
  }
}
export interface DownloadResult {
  success: boolean;
  error?: string;
  data?: string; // Base64 编码的文件内容
  contentType?: string;
  fileName?: string;
}
/**
 * 下载存储文件
 * 返回 Base64 编码的文件内容，前端可以直接下载
 */
export async function downloadStorageFile(
  fileName: string,
  source: "supabase" | "cloudbase",
  fileId?: string
): Promise<DownloadResult> {
  try {
    await requireAdmin();
    if (source === "supabase") {
      if (!supabaseAdmin) {
        return { success: false, error: "Supabase 未配置" };
      }
      const { data, error } = await supabaseAdmin.storage
        .from("ads")
        .download(fileName);
      if (error || !data) {
        console.error("Supabase download error:", error);
        return { success: false, error: "下载文件失败" };
      }
      const buffer = Buffer.from(await data.arrayBuffer());
      return {
        success: true,
        data: buffer.toString("base64"),
        contentType: data.type,
        fileName,
      };
    } else if (source === "cloudbase") {
      if (!fileId || !fileId.startsWith("cloud://")) {
        return { success: false, error: "无效的 CloudBase fileId" };
      }
      const connector = new CloudBaseConnector();
      await connector.initialize();
      const app = connector.getApp();
      const downloadResult = await app.downloadFile({
        fileID: fileId,
      });
      if (!downloadResult.fileContent) {
        console.error("CloudBase download failed: no fileContent");
        return { success: false, error: "下载文件失败" };
      }
      // fileContent 是 Buffer
      const buffer = Buffer.from(downloadResult.fileContent);
      // 根据文件扩展名推断 contentType
      const ext = fileName.split(".").pop()?.toLowerCase();
      let contentType = "application/octet-stream";
      if (ext) {
        const mimeTypes: Record<string, string> = {
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          png: "image/png",
          gif: "image/gif",
          webp: "image/webp",
          svg: "image/svg+xml",
          mp4: "video/mp4",
          webm: "video/webm",
          mov: "video/quicktime",
          avi: "video/x-msvideo",
        };
        contentType = mimeTypes[ext] || contentType;
      }
      return {
        success: true,
        data: buffer.toString("base64"),
        contentType,
        fileName,
      };
    }
    return { success: false, error: "不支持的数据源" };
  } catch (err) {
    console.error("Download storage file error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "下载文件失败",
    };
  }
}
"use server";
/**
 * 管理员认证 Server Actions
 */
import { supabaseAdmin } from "@/lib/supabaseAdmin";
import {
  getSupabaseServiceRoleKeyFromEnv,
  getSupabaseUrlFromEnv,
} from "@/lib/supabase/env";
import { verifyPassword, hashPassword } from "@/utils/password";
import {
  createAdminSession,
  destroyAdminSession,
  getAdminSession,
} from "@/utils/session";
import { redirect } from "next/navigation";
function getSupabaseAdminDebugInfo() {
  const url = getSupabaseUrlFromEnv();
  let urlHost: string | null = null;
  if (url) {
    try {
      urlHost = new URL(url).host;
    } catch {
      urlHost = null;
    }
  }
  return {
    edition: (process.env.NEXT_PUBLIC_DEFAULT_LANGUAGE || "zh").toLowerCase(),
    supabaseUrlHost: urlHost,
    hasServiceRoleKey: Boolean(getSupabaseServiceRoleKeyFromEnv()),
  };
}
let lastAdminUserNotFoundLogAt = 0;
function logAdminUserNotFoundRateLimited() {
  const now = Date.now();
  // 避免被暴力尝试刷屏：最多每分钟输出一次
  if (now - lastAdminUserNotFoundLogAt < 60_000) return;
  lastAdminUserNotFoundLogAt = now;
  const debug = getSupabaseAdminDebugInfo();
  console.warn("[adminLogin] Admin user not found", debug);
}
export interface LoginResult {
  success: boolean;
  error?: string;
}
export interface ChangePasswordResult {
  success: boolean;
  error?: string;
}
/**
 * 管理员登录
 */
export async function adminLogin(
  formData: FormData
): Promise<LoginResult> {
  const username = formData.get("username") as string;
  const password = formData.get("password") as string;
  if (!username || !password) {
    return { success: false, error: "请输入用户名和密码" };
  }
  if (!supabaseAdmin) {
    return { success: false, error: "数据库连接失败" };
  }
  try {
    // 从数据库查询管理员
    const { data: admin, error } = await supabaseAdmin
      .from("admin_users")
      .select("id, username, password_hash")
      .eq("username", username)
      .maybeSingle();
    if (error) {
      const debug = getSupabaseAdminDebugInfo();
      console.error("[adminLogin] Supabase query failed", {
        ...debug,
        code: (error as any)?.code,
        message: error.message,
        details: (error as any)?.details,
        hint: (error as any)?.hint,
      });
      return { success: false, error: "用户名或密码错误" };
    }
    if (!admin) {
      logAdminUserNotFoundRateLimited();
      return { success: false, error: "用户名或密码错误" };
    }
    // 验证密码
    const isValid = await verifyPassword(password, admin.password_hash);
    if (!isValid) {
      return { success: false, error: "用户名或密码错误" };
    }
    // 创建会话
    await createAdminSession(admin.id, admin.username);
    return { success: true };
  } catch (err) {
    const debug = getSupabaseAdminDebugInfo();
    const safeErr =
      err instanceof Error
        ? { name: err.name, message: err.message, stack: err.stack }
        : { error: err };
    console.error("[adminLogin] Unexpected error", { ...debug, ...safeErr });
    return { success: false, error: "登录失败，请稍后重试" };
  }
}
/**
 * 管理员登出
 */
export async function adminLogout(): Promise<void> {
  await destroyAdminSession();
  redirect("/admin/login");
}
/**
 * 修改密码
 */
export async function changePassword(
  formData: FormData
): Promise<ChangePasswordResult> {
  const currentPassword = formData.get("currentPassword") as string;
  const newPassword = formData.get("newPassword") as string;
  const confirmPassword = formData.get("confirmPassword") as string;
  if (!currentPassword || !newPassword || !confirmPassword) {
    return { success: false, error: "请填写所有字段" };
  }
  if (newPassword !== confirmPassword) {
    return { success: false, error: "两次输入的新密码不一致" };
  }
  if (newPassword.length < 6) {
    return { success: false, error: "新密码长度至少 6 位" };
  }
  const session = await getAdminSession();
  if (!session) {
    return { success: false, error: "未登录" };
  }
  if (!supabaseAdmin) {
    return { success: false, error: "数据库连接失败" };
  }
  try {
    // 获取当前用户信息
    const { data: admin, error: fetchError } = await supabaseAdmin
      .from("admin_users")
      .select("id, password_hash")
      .eq("id", session.userId)
      .single();
    if (fetchError || !admin) {
      return { success: false, error: "获取用户信息失败" };
    }
    // 验证当前密码
    const isValid = await verifyPassword(currentPassword, admin.password_hash);
    if (!isValid) {
      return { success: false, error: "当前密码错误" };
    }
    // 生成新密码哈希
    const newHash = await hashPassword(newPassword);
    // 更新密码
    const { error: updateError } = await supabaseAdmin
      .from("admin_users")
      .update({ password_hash: newHash })
      .eq("id", session.userId);
    if (updateError) {
      return { success: false, error: "更新密码失败" };
    }
    return { success: true };
  } catch (err) {
    console.error("Change password error:", err);
    return { success: false, error: "修改密码失败，请稍后重试" };
  }
}
/**
 * 获取当前管理员信息
 */
export async function getCurrentAdmin() {
  const session = await getAdminSession();
  if (!session) return null;
  return {
    userId: session.userId,
    username: session.username,
  };
}
"use server";
/**
 * 发布版本管理 Server Actions
 * 实现双端同步：Supabase (国际版) + CloudBase (国内版)
 */
import { supabaseAdmin } from "@/lib/supabaseAdmin";
import { CloudBaseConnector } from "@/lib/cloudbase/connector";
import { getAdminSession } from "@/utils/session";
import { revalidatePath } from "next/cache";
// 平台类型
export type Platform = "ios" | "android" | "windows" | "macos" | "linux";
// 变体类型（针对不同架构/格式）
export type Variant =
  | "default"
  // macOS
  | "intel" | "m"
  // Windows
  | "x64" | "x86" | "arm64"
  // Linux
  | "deb" | "appimage" | "snap" | "flatpak" | "aur" | "rpm";
// 发布版本类型定义
export interface AppRelease {
  id: string;
  version: string;
  platform: Platform;
  variant?: Variant;
  file_url: string;
  file_size?: number;
  release_notes?: string;
  is_active: boolean;
  is_mandatory: boolean;
  created_at: string;
  updated_at?: string;
  source: "supabase" | "cloudbase" | "both";
}
export interface CreateReleaseResult {
  success: boolean;
  error?: string;
  data?: AppRelease;
}
export interface UpdateReleaseResult {
  success: boolean;
  error?: string;
}
export interface DeleteReleaseResult {
  success: boolean;
  error?: string;
}
export interface ListReleasesResult {
  success: boolean;
  error?: string;
  data?: AppRelease[];
}
/**
 * 验证管理员权限
 */
async function requireAdmin() {
  const session = await getAdminSession();
  if (!session) {
    throw new Error("未授权访问");
  }
  return session;
}
/**
 * 获取 CloudBase 客户端
 */
async function getCloudBase() {
  const connector = new CloudBaseConnector();
  await connector.initialize();
  return {
    db: connector.getClient(),
    app: connector.getApp(),
  };
}
/**
 * 上传文件到 Supabase Storage
 */
async function uploadToSupabase(
  file: File,
  fileName: string
): Promise<string | null> {
  if (!supabaseAdmin) return null;
  try {
    const buffer = Buffer.from(await file.arrayBuffer());
    const filePath = `${fileName}`;
    const { error } = await supabaseAdmin.storage
      .from("releases")
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true,
      });
    if (error) {
      console.error("Supabase upload error:", error);
      return null;
    }
    // 获取公开 URL
    const { data: urlData } = supabaseAdmin.storage
      .from("releases")
      .getPublicUrl(filePath);
    return urlData.publicUrl;
  } catch (err) {
    console.error("Supabase upload exception:", err);
    return null;
  }
}
/**
 * 上传文件到 CloudBase Storage
 */
async function uploadToCloudBase(
  file: File,
  fileName: string
): Promise<string | null> {
  try {
    const { app } = await getCloudBase();
    const buffer = Buffer.from(await file.arrayBuffer());
    const cloudPath = `releases/${fileName}`;
    console.log("CloudBase uploading to:", cloudPath);
    const uploadResult = await app.uploadFile({
      cloudPath,
      fileContent: buffer,
    });
    if (!uploadResult.fileID) {
      console.error("CloudBase upload failed: no fileID returned");
      return null;
    }
    console.log("CloudBase upload success, fileID:", uploadResult.fileID);
    return uploadResult.fileID;
  } catch (err) {
    console.error("CloudBase upload exception:", err);
    return null;
  }
}
/**
 * 创建发布版本 - 支持选择上传目标
 */
export async function createRelease(
  formData: FormData
): Promise<CreateReleaseResult> {
  try {
    await requireAdmin();
    const version = formData.get("version") as string;
    const platform = formData.get("platform") as Platform;
    const variant = (formData.get("variant") as Variant) || undefined;
    const releaseNotes = formData.get("releaseNotes") as string;
    const isActive = formData.get("isActive") === "true";
    const isMandatory = formData.get("isMandatory") === "true";
    const file = formData.get("file") as File;
    const uploadTarget = (formData.get("uploadTarget") as string) || "both";
    if (!version || !platform) {
      return { success: false, error: "请填写必要字段" };
    }
    if (!file || file.size === 0) {
      return { success: false, error: "请上传安装包文件" };
    }
    // 生成唯一文件名（包含 variant）
    const ext = file.name.split(".").pop();
    const variantSuffix = variant ? `-${variant}` : "";
    const fileName = `${platform}${variantSuffix}-${version}-${Date.now()}.${ext}`;
    // 根据选择上传到对应存储
    let supabaseUrl: string | null = null;
    let cloudbaseUrl: string | null = null;
    if (uploadTarget === "both" || uploadTarget === "supabase") {
      supabaseUrl = await uploadToSupabase(file, fileName);
      if (!supabaseUrl && (uploadTarget === "supabase" || uploadTarget === "both")) {
        return { success: false, error: "上传到 Supabase 失败" };
      }
    }
    if (uploadTarget === "both" || uploadTarget === "cloudbase") {
      cloudbaseUrl = await uploadToCloudBase(file, fileName);
      if (!cloudbaseUrl && uploadTarget === "cloudbase") {
        return { success: false, error: "上传到 CloudBase 失败" };
      }
    }
    // 生成 UUID
    const id = crypto.randomUUID();
    // 根据选择写入对应数据库
    const results: { supabase?: { error: unknown }; cloudbase?: { error: unknown } } = {};
    if ((uploadTarget === "both" || uploadTarget === "supabase") && supabaseUrl) {
      const supabaseResult = supabaseAdmin
        ? await supabaseAdmin.from("app_releases").insert({
            id,
            version,
            platform,
            variant: variant || null,
            file_url: supabaseUrl,
            file_size: file.size,
            release_notes: releaseNotes || null,
            is_active: isActive,
            is_mandatory: isMandatory,
          })
        : { error: new Error("Supabase not configured") };
      results.supabase = supabaseResult;
      if (supabaseResult.error) {
        console.error("Supabase insert error:", supabaseResult.error);
        if (uploadTarget === "supabase") {
          return { success: false, error: "保存到 Supabase 失败" };
        }
        // 双端模式下 Supabase 插入失败，返回错误
        if (uploadTarget === "both") {
          return { success: false, error: "保存到 Supabase 失败，请检查数据库配置" };
        }
      }
    }
    if ((uploadTarget === "both" || uploadTarget === "cloudbase") && cloudbaseUrl) {
      try {
        const { db } = await getCloudBase();
        // 使用 doc(id).set() 确保使用我们指定的 ID，而不是 add() 自动生成的 ID
        await db.collection("app_releases").doc(id).set({
          version,
          platform,
          variant: variant || null,
          file_url: cloudbaseUrl,
          file_size: file.size,
          release_notes: releaseNotes || null,
          is_active: isActive,
          is_mandatory: isMandatory,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        });
        results.cloudbase = { error: null };
      } catch (err) {
        console.error("CloudBase insert error:", err);
        results.cloudbase = { error: err };
        if (uploadTarget === "cloudbase") {
          return { success: false, error: "保存到 CloudBase 失败" };
        }
        // 双端模式下 CloudBase 插入失败，返回错误
        if (uploadTarget === "both") {
          return { success: false, error: "保存到 CloudBase 失败，请检查数据库配置" };
        }
      }
    }
    // 检查是否至少有一个成功
    const supabaseSuccess = !results.supabase?.error;
    const cloudbaseSuccess = !results.cloudbase?.error;
    if (uploadTarget === "both" && !supabaseSuccess && !cloudbaseSuccess) {
      return { success: false, error: "保存到数据库失败" };
    }
    revalidatePath("/admin/releases");
    // 确定数据源
    let source: "supabase" | "cloudbase" | "both" = "both";
    if (uploadTarget === "supabase") {
      source = "supabase";
    } else if (uploadTarget === "cloudbase") {
      source = "cloudbase";
    }
    return {
      success: true,
      data: {
        id,
        version,
        platform,
        variant,
        file_url: supabaseUrl || cloudbaseUrl || "",
        file_size: file.size,
        release_notes: releaseNotes || undefined,
        is_active: isActive,
        is_mandatory: isMandatory,
        created_at: new Date().toISOString(),
        source,
      },
    };
  } catch (err) {
    console.error("Create release error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "创建发布版本失败",
    };
  }
}
/**
 * 获取发布版本列表（合并 Supabase 和 CloudBase）
 */
export async function listReleases(): Promise<ListReleasesResult> {
  try {
    await requireAdmin();
    const releasesMap = new Map<string, AppRelease>();
    // 从 Supabase 获取
    if (supabaseAdmin) {
      try {
        const { data, error } = await supabaseAdmin
          .from("app_releases")
          .select("*")
          .order("created_at", { ascending: false });
        if (!error && data) {
          for (const release of data) {
            releasesMap.set(release.id, {
              ...release,
              source: "supabase" as const,
            });
          }
        }
      } catch (err) {
        console.warn("Supabase list warning:", err);
      }
    }
    // 从 CloudBase 获取
    try {
      const connector = new CloudBaseConnector();
      await connector.initialize();
      const db = connector.getClient();
      const app = connector.getApp();
      const { data } = await db
        .collection("app_releases")
        .orderBy("created_at", "desc")
        .get();
      console.log("CloudBase releases count:", data?.length || 0);
      if (data && Array.isArray(data)) {
        // 收集需要获取临时 URL 的 fileID
        const cloudbaseReleases: { release: any; fileId: string }[] = [];
        for (const release of data) {
          const id = release._id || release.id;
          let fileId: string | null = null;
          // 检查 file_url 是否是 fileID 格式
          if (release.file_url && release.file_url.startsWith("cloud://")) {
            fileId = release.file_url;
          }
          if (releasesMap.has(id)) {
            // 两边都有，标记为 both
            const existing = releasesMap.get(id)!;
            releasesMap.set(id, { ...existing, source: "both" });
          } else {
            // 只在 CloudBase 有
            releasesMap.set(id, {
              id,
              version: release.version,
              platform: release.platform,
              file_url: release.file_url,
              file_size: release.file_size,
              release_notes: release.release_notes,
              is_active: release.is_active,
              is_mandatory: release.is_mandatory,
              created_at: release.created_at,
              updated_at: release.updated_at,
              source: "cloudbase" as const,
            });
            if (fileId) {
              cloudbaseReleases.push({ release: { ...release, id }, fileId });
            }
          }
        }
        // 批量获取 CloudBase 文件的临时 URL
        if (cloudbaseReleases.length > 0) {
          try {
            const fileIds = cloudbaseReleases.map((item) => item.fileId);
            const urlResult = await app.getTempFileURL({
              fileList: fileIds,
            });
            if (urlResult.fileList && Array.isArray(urlResult.fileList)) {
              const urlMap = new Map<string, string>();
              for (const fileInfo of urlResult.fileList) {
                if (fileInfo.tempFileURL && fileInfo.code === "SUCCESS") {
                  urlMap.set(fileInfo.fileID, fileInfo.tempFileURL);
                }
              }
              // 更新 releasesMap 中的 file_url
              for (const { release, fileId } of cloudbaseReleases) {
                const tempUrl = urlMap.get(fileId);
                if (tempUrl) {
                  const existing = releasesMap.get(release.id);
                  if (existing) {
                    releasesMap.set(release.id, { ...existing, file_url: tempUrl });
                  }
                }
              }
            }
          } catch (urlErr) {
            console.error("CloudBase getTempFileURL error:", urlErr);
          }
        }
      }
    } catch (err) {
      console.error("CloudBase list error:", err);
    }
    // 转换为数组并排序
    const releases = Array.from(releasesMap.values()).sort((a, b) => {
      return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    });
    return { success: true, data: releases };
  } catch (err) {
    console.error("List releases error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "获取发布版本列表失败",
    };
  }
}
/**
 * 更新发布版本 - 双端同步
 */
export async function updateRelease(
  id: string,
  formData: FormData
): Promise<UpdateReleaseResult> {
  try {
    await requireAdmin();
    const releaseNotes = formData.get("releaseNotes") as string;
    const isActive = formData.get("isActive") === "true";
    const isMandatory = formData.get("isMandatory") === "true";
    const updates = {
      release_notes: releaseNotes || null,
      is_active: isActive,
      is_mandatory: isMandatory,
      updated_at: new Date().toISOString(),
    };
    // 并发更新两个数据库
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin.from("app_releases").update(updates).eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("app_releases").doc(id).update(updates);
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase update error:", supabaseResult.error);
      return { success: false, error: "更新失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase update warning:", cloudbaseResult.error);
    }
    revalidatePath("/admin/releases");
    return { success: true };
  } catch (err) {
    console.error("Update release error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "更新发布版本失败",
    };
  }
}
/**
 * 切换发布版本状态（启用/禁用）- 双端同步
 */
export async function toggleReleaseStatus(
  id: string,
  isActive: boolean
): Promise<UpdateReleaseResult> {
  try {
    await requireAdmin();
    const updates = {
      is_active: isActive,
      updated_at: new Date().toISOString(),
    };
    // 并发更新两个数据库
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin.from("app_releases").update(updates).eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("app_releases").doc(id).update(updates);
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase toggle error:", supabaseResult.error);
      return { success: false, error: "切换状态失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase toggle warning:", cloudbaseResult.error);
    }
    revalidatePath("/admin/releases");
    return { success: true };
  } catch (err) {
    console.error("Toggle release error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "切换状态失败",
    };
  }
}
/**
 * 删除发布版本 - 双端同步（硬删除）
 */
export async function deleteRelease(id: string): Promise<DeleteReleaseResult> {
  try {
    await requireAdmin();
    // 先获取版本信息以便删除存储文件
    let fileUrl: string | null = null;
    if (supabaseAdmin) {
      const { data } = await supabaseAdmin
        .from("app_releases")
        .select("file_url")
        .eq("id", id)
        .single();
      fileUrl = data?.file_url;
    }
    // 并发删除两个数据库的记录
    const supabasePromise = supabaseAdmin
      ? supabaseAdmin.from("app_releases").delete().eq("id", id)
      : Promise.resolve({ error: new Error("Supabase not configured") });
    const cloudbasePromise = (async () => {
      try {
        const { db } = await getCloudBase();
        await db.collection("app_releases").doc(id).remove();
        return { error: null };
      } catch (err) {
        return { error: err };
      }
    })();
    const [supabaseResult, cloudbaseResult] = await Promise.all([
      supabasePromise,
      cloudbasePromise,
    ]);
    if (supabaseResult.error) {
      console.error("Supabase delete error:", supabaseResult.error);
      return { success: false, error: "删除失败" };
    }
    if (cloudbaseResult.error) {
      console.warn("CloudBase delete warning:", cloudbaseResult.error);
    }
    // 尝试删除存储文件（可选，不影响主流程）
    if (fileUrl && supabaseAdmin) {
      try {
        const urlParts = fileUrl.split("/releases/");
        if (urlParts.length > 1) {
          const fileName = urlParts[1].split("?")[0];
          await supabaseAdmin.storage.from("releases").remove([fileName]);
        }
      } catch (err) {
        console.warn("Delete storage file warning:", err);
      }
    }
    revalidatePath("/admin/releases");
    return { success: true };
  } catch (err) {
    console.error("Delete release error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "删除发布版本失败",
    };
  }
}
/**
 * 获取最新版本（按平台）
 * 用于客户端检查更新
 */
export async function getLatestRelease(
  platform: Platform
): Promise<{ success: boolean; data?: AppRelease; error?: string }> {
  try {
    // 从 Supabase 获取
    if (supabaseAdmin) {
      const { data, error } = await supabaseAdmin
        .from("app_releases")
        .select("*")
        .eq("platform", platform)
        .eq("is_active", true)
        .order("created_at", { ascending: false })
        .limit(1)
        .single();
      if (!error && data) {
        return {
          success: true,
          data: {
            ...data,
            source: "supabase" as const,
          },
        };
      }
    }
    // 如果 Supabase 没有，尝试从 CloudBase 获取
    try {
      const { db, app } = await getCloudBase();
      const { data } = await db
        .collection("app_releases")
        .where({
          platform,
          is_active: true,
        })
        .orderBy("created_at", "desc")
        .limit(1)
        .get();
      if (data && data.length > 0) {
        const release = data[0];
        // 如果是 cloud:// 格式，获取临时 URL
        let fileUrl = release.file_url;
        if (fileUrl && fileUrl.startsWith("cloud://")) {
          try {
            const urlResult = await app.getTempFileURL({
              fileList: [fileUrl],
            });
            if (urlResult.fileList?.[0]?.code === "SUCCESS") {
              fileUrl = urlResult.fileList[0].tempFileURL;
            }
          } catch {
            // 使用原 URL
          }
        }
        return {
          success: true,
          data: {
            id: release._id || release.id,
            version: release.version,
            platform: release.platform,
            file_url: fileUrl,
            file_size: release.file_size,
            release_notes: release.release_notes,
            is_active: release.is_active,
            is_mandatory: release.is_mandatory,
            created_at: release.created_at,
            updated_at: release.updated_at,
            source: "cloudbase" as const,
          },
        };
      }
    } catch (err) {
      console.error("CloudBase getLatestRelease error:", err);
    }
    return { success: false, error: "未找到可用版本" };
  } catch (err) {
    console.error("Get latest release error:", err);
    return {
      success: false,
      error: err instanceof Error ? err.message : "获取最新版本失败",
    };
  }
}
// ============================================================================
// 文件管理相关
// ============================================================================
export interface ReleaseFile {
  name: string;
  url: string;
  size?: number;
  lastModified?: string;
  source: "supabase" | "cloudbase";
  fileId?: string;
  releaseId?: string;
  version?: string;
  platform?: Platform;
}
export interface ListReleaseFilesResult {
  success: boolean;
  error?: string;
  supabaseFiles?: ReleaseFile[];
  cloudbaseFiles?: ReleaseFile[];
}
export interface FileOperationResult {
  success: boolean;
  error?: string;
}
export interface DownloadResult {
  success: boolean;
  error?: string;
  data?: string;
  contentType?: string;
  fileName?: string;
}
/**
 * 列出发布版本文件 - 两个云存储
 */
export async function listReleaseFiles(): Promise<ListReleaseFilesResult> {
  try {
    await requireAdmin();
    const supabaseFiles: ReleaseFile[] = [];
    const cloudbaseFiles: ReleaseFile[] = [];
    // 获取 Supabase Storage 文件
    if (supabaseAdmin) {
      try {
        // 获取 releases bucket 文件列表
        const { data: files, error } = await supabaseAdmin.storage
          .from("releases")
          .list("", { limit: 100 });
        if (!error && files) {
          // 同时获取数据库中的版本信息
          const { data: releases } = await supabaseAdmin
            .from("app_releases")
            .select("id, version, platform, file_url, file_size, created_at");
          // 创建 URL -> release 映射
          const urlToRelease = new Map<string, any>();
          if (releases) {
            for (const release of releases) {
              if (release.file_url) {
                const urlParts = release.file_url.split("/releases/");
                if (urlParts.length > 1) {
                  const fileName = decodeURIComponent(urlParts[1].split("?")[0]);
                  urlToRelease.set(fileName, release);
                }
              }
            }
          }
          for (const file of files) {
            if (file.name === ".emptyFolderPlaceholder") continue;
            const { data: urlData } = supabaseAdmin.storage
              .from("releases")
              .getPublicUrl(file.name);
            const release = urlToRelease.get(file.name);
            supabaseFiles.push({
              name: file.name,
              url: urlData.publicUrl,
              size: release?.file_size || file.metadata?.size,
              lastModified: release?.created_at || file.updated_at,
              source: "supabase",
              releaseId: release?.id,
              version: release?.version,
              platform: release?.platform,
            });
          }
        }
      } catch (err) {
        console.warn("List Supabase release files warning:", err);
      }
    }
    // 获取 CloudBase Storage 文件
    try {
      const connector = new CloudBaseConnector();
      await connector.initialize();
      const db = connector.getClient();
      const app = connector.getApp();
      const { data } = await db.collection("app_releases").get();
      if (data && Array.isArray(data)) {
        const fileIdList: string[] = [];
        const releaseMap: Map<string, { release: any; fileName: string }> = new Map();
        for (const release of data) {
          if (release.file_url) {
            let fileId: string | null = null;
            let fileName: string;
            if (release.file_url.startsWith("cloud://")) {
              fileId = release.file_url;
              const pathParts = release.file_url.split("/");
              fileName = pathParts[pathParts.length - 1] || release._id;
            } else {
              const urlParts = release.file_url.split("/");
              fileName = urlParts[urlParts.length - 1]?.split("?")[0] || release._id;
              cloudbaseFiles.push({
                name: fileName,
                url: release.file_url,
                size: release.file_size,
                lastModified: release.created_at,
                source: "cloudbase",
                fileId: undefined,
                releaseId: release._id || release.id,
                version: release.version,
                platform: release.platform,
              });
              continue;
            }
            if (fileId) {
              fileIdList.push(fileId);
              releaseMap.set(fileId, { release, fileName });
=============== 前 30 页代码结束 ===============
=============== 后 30 页代码开始 ===============
 */
export async function checkDailyExternalQuota(
  userId: string,
  planLower: string,
  count: number = 1
): Promise<{ allowed: boolean; remaining: number; limit: number }> {
  const connector = new CloudBaseConnector();
  await connector.initialize();
  const db = connector.getClient();
  const today = getTodayString();
  const limit = getPlanDailyLimit(planLower);
  const userRes = await db.collection("users").doc(userId).get();
  const userDoc = userRes?.data?.[0] || null;
  if (!userDoc) return { allowed: false, remaining: 0, limit };
  const wallet = normalizeWallet(userDoc);
  const isNewDay = wallet.daily_external_day !== today;
  const isPlanChanged =
    !!wallet.daily_external_plan && wallet.daily_external_plan !== planLower;
  const used = isNewDay || isPlanChanged ? 0 : wallet.daily_external_used || 0;
  if (isNewDay || isPlanChanged) {
    await db.collection("users").doc(userId).update({
      "wallet.daily_external_used": 0,
      "wallet.daily_external_day": today,
      "wallet.daily_external_plan": planLower,
      updatedAt: new Date().toISOString(),
    });
  }
  return {
    allowed: used + count <= limit,
    remaining: Math.max(0, limit - used - count),
    limit,
  };
}
export async function consumeDailyExternalQuota(
  userId: string,
  planLower: string,
  count: number = 1
): Promise<{ success: boolean; error?: string }> {
  try {
    const connector = new CloudBaseConnector();
    await connector.initialize();
    const db = connector.getClient();
    const _ = db.command;
    const today = getTodayString();
    const limit = getPlanDailyLimit(planLower);
    const userRes = await db.collection("users").doc(userId).get();
    const userDoc = userRes?.data?.[0] || null;
    if (!userDoc) return { success: false, error: "User not found" };
    const wallet = normalizeWallet(userDoc);
    const isNewDay = wallet.daily_external_day !== today;
    const isPlanChanged =
      !!wallet.daily_external_plan && wallet.daily_external_plan !== planLower;
    const used = isNewDay || isPlanChanged ? 0 : wallet.daily_external_used || 0;
    const nextUsed = used + count;
    if (nextUsed > limit) return { success: false, error: "Insufficient daily quota" };
    const updatePayload: Record<string, any> = {
      updatedAt: new Date().toISOString(),
      "wallet.daily_external_plan": planLower,
    };
    if (isNewDay || isPlanChanged) {
      updatePayload["wallet.daily_external_used"] = count;
      updatePayload["wallet.daily_external_day"] = today;
    } else {
      updatePayload["wallet.daily_external_used"] = _.inc(count);
    }
    await db.collection("users").doc(userId).update(updatePayload);
    console.log("[wallet][consume-daily]", {
      userId,
      planLower,
      count,
      usedBefore: used,
      usedAfter: nextUsed,
      day: today,
    });
    return { success: true };
  } catch (error) {
    console.error("[wallet][consume-daily-error]", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to consume daily quota",
    };
  }
}
// =============================================================================
// FEFO 扣费
// =============================================================================
/**
 * 智能扣费 FEFO：先月度，再加油包
 * 兼容旧结构和新结构钱包
 */
export async function consumeQuota(
  request: QuotaDeductionRequest
): Promise<QuotaDeductionResult> {
  const { userId, imageCount = 0, videoAudioCount = 0 } = request;
  if (imageCount <= 0 && videoAudioCount <= 0) return { success: true };
  try {
    const connector = new CloudBaseConnector();
    await connector.initialize();
    const db = connector.getClient();
    const wallet = await getUserWallet(userId);
    if (!wallet) return { success: false, error: "User wallet not found" };
    const deducted = { monthly_image: 0, monthly_video: 0, addon_image: 0, addon_video: 0 };
    // 图片
    let imgNeed = imageCount;
    if (imgNeed > 0 && wallet.monthly_image_balance > 0) {
      const d = Math.min(imgNeed, wallet.monthly_image_balance);
      deducted.monthly_image = d;
      imgNeed -= d;
    }
    if (imgNeed > 0 && wallet.addon_image_balance > 0) {
      const d = Math.min(imgNeed, wallet.addon_image_balance);
      deducted.addon_image = d;
      imgNeed -= d;
    }
    if (imgNeed > 0) return { success: false, error: "Insufficient image quota" };
    // 视频/音频
    let mediaNeed = videoAudioCount;
    if (mediaNeed > 0 && wallet.monthly_video_balance > 0) {
      const d = Math.min(mediaNeed, wallet.monthly_video_balance);
      deducted.monthly_video = d;
      mediaNeed -= d;
    }
    if (mediaNeed > 0 && wallet.addon_video_balance > 0) {
      const d = Math.min(mediaNeed, wallet.addon_video_balance);
      deducted.addon_video = d;
      mediaNeed -= d;
    }
    if (mediaNeed > 0) return { success: false, error: "Insufficient video/audio quota" };
    // 计算新余额（使用绝对值更新，避免 _.inc 在字段不存在时失败）
    const remaining = {
      monthly_image_balance: wallet.monthly_image_balance - deducted.monthly_image,
      monthly_video_balance: wallet.monthly_video_balance - deducted.monthly_video,
      addon_image_balance: wallet.addon_image_balance - deducted.addon_image,
      addon_video_balance: wallet.addon_video_balance - deducted.addon_video,
    };
    await db.collection("users").doc(userId).update({
      "wallet.monthly_image_balance": remaining.monthly_image_balance,
      "wallet.monthly_video_balance": remaining.monthly_video_balance,
      "wallet.addon_image_balance": remaining.addon_image_balance,
      "wallet.addon_video_balance": remaining.addon_video_balance,
      updatedAt: new Date().toISOString(),
    });
    console.log("[wallet][consume-quota]", {
      userId,
      requested: { imageCount, videoAudioCount },
      deducted,
      remaining,
      timestamp: new Date().toISOString(),
    });
    return { success: true, deducted, remaining };
  } catch (error) {
    console.error("[wallet][consume-quota-error]", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to consume quota",
    };
  }
}
/**
 * 检查用户配额是否充足
 */
export async function checkQuota(
  userId: string,
  requiredImages: number = 0,
  requiredVideoAudio: number = 0
): Promise<QuotaCheckResult> {
  const wallet = await getUserWallet(userId);
  if (!wallet) {
    return {
      hasEnoughQuota: false,
      totalImageBalance: 0,
      totalVideoBalance: 0,
      monthlyImageBalance: 0,
      monthlyVideoBalance: 0,
      addonImageBalance: 0,
      addonVideoBalance: 0,
    };
  }
  const totalImageBalance = wallet.monthly_image_balance + wallet.addon_image_balance;
  const totalVideoBalance = wallet.monthly_video_balance + wallet.addon_video_balance;
  const hasEnoughQuota =
    totalImageBalance >= requiredImages && totalVideoBalance >= requiredVideoAudio;
  return {
    hasEnoughQuota,
    totalImageBalance,
    totalVideoBalance,
    monthlyImageBalance: wallet.monthly_image_balance,
    monthlyVideoBalance: wallet.monthly_video_balance,
    addonImageBalance: wallet.addon_image_balance,
    addonVideoBalance: wallet.addon_video_balance,
  };
}
/**
 * 计算升级补差价
 *
 * 升级机制说明：
 * 1. 用户从低级套餐升级到高级套餐时，需要支付剩余订阅期内的差价
 * 2. 计算公式：(目标套餐日价 - 当前套餐日价) × 剩余天数
 * 3. 升级后，订阅到期时间保持不变，用户在剩余期间享受新套餐权益
 * 4. 到期后按新套餐价格续费
 *
 * 示例：
 * - 用户有Basic月订阅，剩余120天，想升级到Pro月订阅
 * - Basic日价 = ¥29/30 = ¥0.97/天
 * - Pro日价 = ¥99/30 = ¥3.30/天
 * - 差价 = (3.30 - 0.97) × 120 = ¥280
 *
 * @param currentPlanDailyPrice 当前套餐的日价格
 * @param targetPlanDailyPrice 目标套餐的日价格
 * @param remainingDays 当前订阅剩余天数
 * @param minimumPayment 最低支付金额（避免支付接口报错），默认0.01
 * @returns 升级需要支付的金额
 */
export function calculateUpgradePrice(
  currentPlanDailyPrice: number,
  targetPlanDailyPrice: number,
  remainingDays: number,
  minimumPayment: number = 0.01
): number {
  // 计算每日差价
  const dailyDifference = targetPlanDailyPrice - currentPlanDailyPrice;
  // 计算总升级价格
  const upgradePrice = dailyDifference * remainingDays;
  console.log("[wallet][calculate-upgrade-price]", {
    currentPlanDailyPrice,
    targetPlanDailyPrice,
    dailyDifference,
    remainingDays,
    rawUpgradePrice: upgradePrice,
  });
  // 确保最低支付金额（支付接口不接受0或负数）
  const finalPrice = Math.max(minimumPayment, upgradePrice);
  console.log("[wallet][calculate-upgrade-price] Final price:", finalPrice);
  return Math.round(finalPrice * 100) / 100;
}
-- ===========================================================================
-- 用户广告设置迁移 (User Ads Settings Migration)
-- 为订阅用户添加去除广告的设置字段
-- ===========================================================================
-- 1. 在 profiles 表中添加 hide_ads 字段
-- 用于存储订阅用户是否开启去除广告功能
-- 默认为 false，订阅用户需要在【下载 MornGPT】页面的【广告设置】中手动开启
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS hide_ads boolean DEFAULT false;
-- 2. 添加注释说明字段用途
COMMENT ON COLUMN public.profiles.hide_ads IS '订阅用户是否开启去除广告功能。默认false，需在广告设置中手动开启。订阅到期后自动失效恢复广告显示。';
-- 3. 创建索引以优化查询（可选，如果需要按此字段筛选用户）
CREATE INDEX IF NOT EXISTS idx_profiles_hide_ads ON public.profiles(hide_ads) WHERE hide_ads = true;
-- ===========================================================================
-- 广告显示逻辑说明：
-- ===========================================================================
--
-- 1. Free 用户：始终显示广告，可手动关闭单个广告（刷新后恢复），关闭后弹出订阅提示
-- 2. 订阅用户 + hide_ads = false：正常显示广告
-- 3. 订阅用户 + hide_ads = true + 订阅有效：不显示广告
-- 4. 订阅用户 + hide_ads = true + 订阅过期：自动恢复广告显示
--
-- 侧边栏小眼睛图标：
-- - 默认状态：显示 Eye 图标（表示广告正在显示）
-- - 点击后：切换到 EyeOff 图标，仅关闭侧边栏广告并显示社交链接列表
-- - 此操作不影响其他位置的广告显示
--
-- ===========================================================================
-- 国内版 CloudBase 数据库变更说明：
-- ===========================================================================
--
-- CloudBase 没有 profiles 集合，用户信息存储在 【users】 集合中。
-- 需要在 【users】 集合中添加以下字段：
--
-- 字段名：hide_ads
-- 类型：Boolean
-- 默认值：false
-- 说明：订阅用户是否开启去除广告功能
--
-- 示例文档结构：
-- {
--   "_id": "4289fa816940daa607e829b81301fdb2",
--   "email": "user@example.com",
--   "name": "用户名",
--   "plan": "Basic",
--   "plan_exp": "2026-01-15T05:51:42.087Z",
--   "pro": true,
--   "hide_ads": false,  // <-- 新增字段
--   "wallet": { ... },
--   ...
-- }
--
-- ===========================================================================
-- ===========================================================================
-- 添加 messages 表缺失的列
-- 注意：conversations 表的 model_type 和 expert_model_id 已在 migration 9 中定义
-- ===========================================================================
-- 添加 folder_id 列 (用于对话文件夹功能)
ALTER TABLE public.conversations
ADD COLUMN IF NOT EXISTS folder_id TEXT;
CREATE INDEX IF NOT EXISTS idx_conversations_folder_id
ON public.conversations(folder_id);
-- ===========================================================================
-- messages 表字段
-- ===========================================================================
-- 添加 tokens 列 (用于记录消息的 token 数量)
ALTER TABLE public.messages
ADD COLUMN IF NOT EXISTS tokens INTEGER;
-- 添加 client_id 列 (用于消息去重)
ALTER TABLE public.messages
ADD COLUMN IF NOT EXISTS client_id TEXT;
-- 添加媒体文件 ID 列 (用于多模态模型)
ALTER TABLE public.messages
ADD COLUMN IF NOT EXISTS image_file_ids JSONB DEFAULT '[]'::jsonb;
ALTER TABLE public.messages
ADD COLUMN IF NOT EXISTS video_file_ids JSONB DEFAULT '[]'::jsonb;
-- 创建索引
CREATE INDEX IF NOT EXISTS idx_messages_client_id
ON public.messages(client_id);
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id
ON public.messages(conversation_id);
-- ===========================================================================
-- 修复 user_wallets 表的 RLS 策略，允许用户更新自己的钱包数据
-- ===========================================================================
-- 删除旧的只读策略
DROP POLICY IF EXISTS "Users view own wallet" ON public.user_wallets;
-- 创建新的完整 CRUD 策略
CREATE POLICY "Users manage own wallet" ON public.user_wallets
FOR ALL USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
-- ===========================================================================
-- Migration: 将 pending_downgrade 从 text 改为 jsonb 以支持多重降级队列
-- ===========================================================================
-- 1. 修改 user_wallets 表的 pending_downgrade 字段类型
-- 从 text 改为 jsonb，支持存储数组格式的降级队列
ALTER TABLE public.user_wallets
  ALTER COLUMN pending_downgrade TYPE jsonb
  USING CASE
    WHEN pending_downgrade IS NULL THEN NULL
    WHEN pending_downgrade = '' THEN NULL
    ELSE pending_downgrade::jsonb
  END;
-- 2. 添加注释说明字段用途
COMMENT ON COLUMN public.user_wallets.pending_downgrade IS
  '待生效的降级订阅队列，jsonb数组格式: [{targetPlan, effectiveAt, expiresAt}, ...]，按等级降序排列（高级先生效）';
-- ===========================================================================
-- Supabase 最终版全量构建脚本 (修复 2BP01 依赖报错 + 唯一约束版)
-- ===========================================================================
-- ⚠️ 警告：以下操作会级联删除 public 下的所有业务数据！
-- ===========================================================================
-- 1. 彻底清理旧环境 (Nuke Phase)
-- ===========================================================================
begin;
  -- 1.1 清理 auth.users 上的残留触发器 (这是报错的核心原因)
  drop trigger if exists on_auth_user_created on auth.users;
  drop trigger if exists on_auth_user_confirmed on auth.users; -- [新增] 移除那个导致报错的残留触发器
  -- 1.2 清理函数 (使用 CASCADE 强力清除任何依赖)
  drop function if exists public.handle_new_user() cascade;
  drop function if exists public.handle_user_confirmed() cascade; -- [修改] 加上 CASCADE 解决 2BP01 错误
  -- 1.3 移除所有业务表 (使用 CASCADE 强力清除表之间的外键依赖)
  drop table if exists public.messages cascade;
  drop table if exists public.conversations cascade;
  drop table if exists public.payments cascade;
  drop table if exists public.subscriptions cascade;
  drop table if exists public.user_wallets cascade;
  drop table if exists public.profiles cascade;
commit;
-- ===========================================================================
-- 2. 基础配置
-- ===========================================================================
create extension if not exists "pgcrypto";
create extension if not exists "uuid-ossp";
-- 赋予权限
grant usage on schema public to postgres, anon, authenticated, service_role;
-- ===========================================================================
-- 3. 建表 (严格模式：必须包含 Primary Key)
-- ===========================================================================
-- 3.1 Profiles
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  email text,
  name text,
  avatar text,
  region text default 'US',
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  constraint profiles_pkey primary key (id)
);
-- 3.2 User Wallets
create table public.user_wallets (
  user_id uuid not null references auth.users on delete cascade,
  plan text default 'Free',
  subscription_tier text default 'Free',
  plan_exp timestamptz,
  pro boolean default false,
  pending_downgrade text,
  monthly_image_balance integer default 0,
  monthly_video_balance integer default 0,
  monthly_reset_at timestamptz default now(),
  addon_image_balance integer default 0,
  addon_video_balance integer default 0,
  daily_external_day date default current_date,
  daily_external_plan text default 'free',
  daily_external_used integer default 0,
  updated_at timestamptz default now(),
  constraint user_wallets_pkey primary key (user_id)
);
-- 3.3 Subscriptions (关键修改：添加唯一约束)
create table public.subscriptions (
  id uuid default gen_random_uuid(),
  user_id uuid references auth.users on delete cascade,
  plan text not null,
  period text not null,
  status text not null,
  type text default 'SUBSCRIPTION',
  provider text,
  provider_order_id text,
  started_at timestamptz default now(),
  expires_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (id),
  -- [关键修复] 添加唯一约束，防止 ON CONFLICT (user_id) 报错
  constraint subscriptions_user_id_key unique (user_id)
);
-- 3.4 Payments
create table public.payments (
  id uuid default gen_random_uuid(),
  user_id uuid references auth.users on delete cascade,
  amount numeric(10,2) not null,
  currency text default 'USD',
  status text not null,
  type text not null,
  provider text,
  provider_order_id text,
  addon_package_id text,
  image_credits integer default 0,
  video_audio_credits integer default 0,
  created_at timestamptz default now(),
  primary key (id)
);
-- 3.5 Conversations
create table public.conversations (
  id uuid default gen_random_uuid(),
  user_id uuid not null references auth.users on delete cascade,
  title text,
  model text,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (id)
);
-- 3.6 Messages
create table public.messages (
  id uuid default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  user_id uuid not null,
  role text not null,
  content text not null,
  client_id text,
  audio_file_ids jsonb default '[]'::jsonb,
  created_at timestamptz default now(),
  primary key (id)
);
-- ===========================================================================
-- 4. 安全策略 (RLS)
-- ===========================================================================
alter table profiles enable row level security;
alter table user_wallets enable row level security;
alter table subscriptions enable row level security;
alter table payments enable row level security;
alter table conversations enable row level security;
alter table messages enable row level security;
create policy "Users manage own profiles" on profiles for all using (auth.uid() = id);
create policy "Users view own wallet" on user_wallets for select using (auth.uid() = user_id);
create policy "Users view own subscriptions" on subscriptions for select using (auth.uid() = user_id);
create policy "Users view own payments" on payments for select using (auth.uid() = user_id);
create policy "Users manage own conversations" on conversations for all using (auth.uid() = user_id);
create policy "Users manage own messages" on messages for all using (auth.uid() = user_id);
-- ===========================================================================
-- 5. 自动化 (触发器)
-- ===========================================================================
create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- 1. 插入 Profile
  insert into public.profiles (id, email, name, avatar)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', split_part(new.email, '@', 1)),
    coalesce(new.raw_user_meta_data->>'avatar_url', '')
  )
  on conflict (id) do nothing;
  -- 2. 插入 Wallet
  insert into public.user_wallets (
    user_id,
    plan,
    subscription_tier,
    monthly_image_balance,
    monthly_video_balance,
    addon_image_balance,
    addon_video_balance,
    daily_external_plan,
    daily_external_used
  )
  values (
    new.id,
    'Free',
    'Free',
    30,
    5,
    0,
    0,
    'free',
    0
  )
  on conflict (user_id) do nothing;
  return new;
exception
  when others then
    raise warning 'Handle new user trigger failed: %', SQLERRM;
    return new;
end;
$$ language plpgsql security definer set search_path = public;
-- 绑定触发器
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
-- ===========================================================================
-- 6. 最终授权
-- ===========================================================================
grant all privileges on all tables in schema public to postgres, service_role;
grant all privileges on all sequences in schema public to postgres, service_role;
grant execute on function public.handle_new_user() to service_role;
-- ===========================================================================
-- 增量补丁：适配防漂移算法 & 并发扣费
-- 只需要运行这一次，不会删除现有数据
-- ===========================================================================
-- 1. 修改 user_wallets 表：添加账单锚点字段
-- 解释：这是为了配合你的 TypeScript 代码中的 getNextBillingDateSticky 算法
-- 它记录用户最初是几号买的（比如31号），防止月份变动导致扣费日漂移
alter table public.user_wallets
add column if not exists billing_cycle_anchor integer;
-- 2. 新增原子扣费函数 (RPC)
-- 解释：这是为了配合 consumeSupabaseQuota 中的 supabase.rpc('deduct_quota')
-- 它能保证在高并发下（比如同时点5次生成），余额不会扣成负数
create or replace function deduct_quota(
  p_user_id uuid,
  p_image_count int,
  p_video_count int
) returns jsonb as $$
declare
  v_wallet public.user_wallets%rowtype;
  v_deducted_monthly_image int := 0;
  v_deducted_addon_image int := 0;
  v_deducted_monthly_video int := 0;
  v_deducted_addon_video int := 0;
  v_remain_image int;
  v_remain_video int;
begin
  -- 锁定行 (Row-level locking) 防止并发修改
  select * into v_wallet from public.user_wallets
  where user_id = p_user_id
  for update;
  if not found then
    return jsonb_build_object('success', false, 'error', 'Wallet not found');
  end if;
  -- === 图片扣减逻辑 (FEFO: 先扣月度，再扣加油包) ===
  v_remain_image := p_image_count;
  if v_remain_image > 0 and v_wallet.monthly_image_balance > 0 then
    v_deducted_monthly_image := least(v_remain_image, v_wallet.monthly_image_balance);
    v_remain_image := v_remain_image - v_deducted_monthly_image;
  end if;
  if v_remain_image > 0 and v_wallet.addon_image_balance > 0 then
    v_deducted_addon_image := least(v_remain_image, v_wallet.addon_image_balance);
    v_remain_image := v_remain_image - v_deducted_addon_image;
  end if;
  if v_remain_image > 0 then
    return jsonb_build_object('success', false, 'error', 'Insufficient image quota');
  end if;
  -- === 视频扣减逻辑 (FEFO) ===
  v_remain_video := p_video_count;
  if v_remain_video > 0 and v_wallet.monthly_video_balance > 0 then
    v_deducted_monthly_video := least(v_remain_video, v_wallet.monthly_video_balance);
    v_remain_video := v_remain_video - v_deducted_monthly_video;
  end if;
  if v_remain_video > 0 and v_wallet.addon_video_balance > 0 then
    v_deducted_addon_video := least(v_remain_video, v_wallet.addon_video_balance);
    v_remain_video := v_remain_video - v_deducted_addon_video;
  end if;
  if v_remain_video > 0 then
    return jsonb_build_object('success', false, 'error', 'Insufficient video quota');
  end if;
  -- === 执行更新 ===
  update public.user_wallets
  set
    monthly_image_balance = monthly_image_balance - v_deducted_monthly_image,
    addon_image_balance = addon_image_balance - v_deducted_addon_image,
    monthly_video_balance = monthly_video_balance - v_deducted_monthly_video,
    addon_video_balance = addon_video_balance - v_deducted_addon_video,
    updated_at = now()
  where user_id = p_user_id;
  return jsonb_build_object(
    'success', true,
    'deducted', jsonb_build_object(
      'monthly_image', v_deducted_monthly_image,
      'addon_image', v_deducted_addon_image,
      'monthly_video', v_deducted_monthly_video,
      'addon_video', v_deducted_addon_video
    )
  );
end;
$$ language plpgsql security definer;
-- ===========================================================================
-- 🛠️ 注册修复补丁：重载 handle_new_user 触发器
-- ===========================================================================
-- 1. 重建 handle_new_user 函数 (确保适配最新的表结构)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  -- 1.1 插入 Profile
  insert into public.profiles (id, email, name, avatar)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', split_part(new.email, '@', 1)),
    coalesce(new.raw_user_meta_data->>'avatar_url', '')
  )
  on conflict (id) do nothing;
  -- 1.2 插入 Wallet (核心修复点)
  -- 我们显式指定所有字段，并为 billing_cycle_anchor 设置默认值
  insert into public.user_wallets (
    user_id,
    plan,
    subscription_tier,
    monthly_image_balance,
    monthly_video_balance,
    addon_image_balance,
    addon_video_balance,
    daily_external_plan,
    daily_external_used,
    billing_cycle_anchor -- 👈 确保插入时涵盖新字段 (虽然它是 nullable，但显式处理更安全)
  )
  values (
    new.id,
    'Free',
    'Free',
    30, -- Free 图片额度
    5,  -- Free 视频额度
    0,
    0,
    'free',
    0,
    EXTRACT(DAY FROM now()) -- 👈 新用户的锚点默认为注册当天的日期
  )
  on conflict (user_id) do nothing;
  return new;
end;
$$ language plpgsql security definer set search_path = public;
-- 2. 确保权限正确 (防止 Permission Denied 导致注册失败)
grant usage on schema public to service_role;
grant all privileges on all tables in schema public to service_role;
grant all privileges on all sequences in schema public to service_role;
grant execute on function public.handle_new_user() to service_role;
-- 3. 验证触发器是否存在 (如果之前被误删，这里会补上)
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
-- 输出修复结果
select 'Registration trigger fixed successfully' as status;
-- =============================================================================
-- 1. 创建广告表 (advertisements)
-- =============================================================================
create table if not exists public.advertisements (
  id uuid default gen_random_uuid() primary key,
  -- 基础信息
  title text not null,           -- 标题 (后台管理用)
  position text not null,        -- 位置标识 (如 "top", "sidebar")
  -- 资源信息
  media_type text not null,      -- 类型 ("image" 或 "video")
  media_url text not null,       -- 资源的完整 URL
  target_url text,               -- 点击跳转链接 (可选)
  -- 控制开关
  is_active boolean default true,-- 上下架状态
  priority int default 0,        -- 轮播权重 (数字越大越靠前)
  -- 审计时间
  created_at timestamptz default now()
);
-- =============================================================================
-- 2. 创建索引 (加速查询)
-- 解释：因为你的查询通常是 "找某个位置 + 必须是激活的 + 按权重排序"
-- =============================================================================
create index if not exists idx_ads_simple
on public.advertisements(position, is_active, priority desc);
-- =============================================================================
-- 3. 启用 RLS (行级安全策略) - 🚨 非常重要
-- 默认情况下，Supabase 拒绝所有未授权的访问。我们需要明确放行。
-- =============================================================================
alter table public.advertisements enable row level security;
-- 策略 A: 允许所有人 (Public) "读取" 广告
-- 条件：只能看到 is_active = true 的广告。
-- (这样你在后台把广告设为 false 后，前端用户就立即看不到了，即使他们知道接口也查不到)
create policy "Public can view active ads"
on public.advertisements for select
using ( is_active = true );
-- 策略 B: 允许后台管理 (Service Role) "所有操作"
-- 注意：Supabase 的 Service Role (你的 Next.js 后端/Admin) 默认拥有所有权限，
-- 甚至不需要这里写 Policy，它会自动绕过 RLS。
-- 所以这里不需要为写操作写额外的 Policy，只要你的 Admin 代码用的是 service_role key 即可。
-- (可选) 如果你的 Admin 后台用的是普通登录用户，你需要取消下面这行的注释并修改邮箱：
-- create policy "Admins can manage ads"
-- on public.advertisements for all
-- using ( auth.jwt() ->> 'email' = '你的管理员邮箱@example.com' );
-- =============================================================================
-- 4. (附赠) 创建 Storage 存储桶并配置权限
-- 这一步是为了让你能上传广告图
-- =============================================================================
-- 4.1 创建一个叫 'ads' 的公共桶
insert into storage.buckets (id, name, public)
values ('ads', 'ads', true)
on conflict (id) do nothing;
-- 4.2 允许所有人读取 'ads' 桶里的图片 (用于前端展示)
create policy "Public Access"
on storage.objects for select
using ( bucket_id = 'ads' );
-- 4.3 允许已登录用户上传图片 (或者你可以限制更严)
create policy "Authenticated users can upload"
on storage.objects for insert
to authenticated
with check ( bucket_id = 'ads' );
-- =============================================================================
-- 0. 启用加密扩展 (为了能在 SQL 里直接算哈希)
-- =============================================================================
create extension if not exists pgcrypto;
-- =============================================================================
-- 1. 创建管理员表
-- =============================================================================
create table if not exists public.admin_users (
  id uuid default gen_random_uuid() primary key,
  username text not null unique,
  password_hash text not null,
  created_at timestamptz default now()
);
-- =============================================================================
-- 2. 解决 RLS 安全警告 (关键步骤)
-- =============================================================================
-- 2.1 开启行级安全
alter table public.admin_users enable row level security;
-- 2.2 我们故意 **不创建** 任何针对 public/authenticated 角色的 Policy。
-- 效果：前端 API (Anon Key) 完全无法访问此表。
-- 只有后端代码 (使用 Service Role Key) 可以绕过 RLS 进行读写。
-- 这对管理员表来说是最安全的设置。
-- =============================================================================
-- 3. 插入初始管理员账号 (自动计算哈希)
-- =============================================================================
insert into public.admin_users (username, password_hash)
values (
  'morngpt',
  -- 使用 crypt 函数直接将明文加密为 bcrypt hash
  crypt('Zyx!213416', gen_salt('bf'))
)
on conflict (username) do nothing; -- 防止重复插入报错
-- =============================================================================
-- 1. 为 advertisements 表添加 file_size 字段
-- =============================================================================
ALTER TABLE public.advertisements
ADD COLUMN IF NOT EXISTS file_size bigint;
COMMENT ON COLUMN public.advertisements.file_size IS '文件大小（字节）';
-- =============================================================================
-- 2. 创建发布版本表 (app_releases)
-- =============================================================================
CREATE TABLE IF NOT EXISTS public.app_releases (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  -- 版本信息
  version text NOT NULL,              -- 版本号 (如 "1.0.0", "2.1.3")
  platform text NOT NULL,             -- 平台 ("ios", "android", "windows", "macos", "linux")
  variant text,                       -- 变体/架构 ("x64", "x86", "arm64", "intel", "m", "deb", "rpm" 等)
  -- 文件信息
  file_url text NOT NULL,             -- 安装包下载地址
  file_size bigint,                   -- 文件大小（字节）
  -- 版本说明
  release_notes text,                 -- 更新日志/版本说明
  -- 控制开关
  is_active boolean DEFAULT true,     -- 是否启用
  is_mandatory boolean DEFAULT false, -- 是否强制更新
  -- 审计时间
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
-- 添加字段注释
COMMENT ON TABLE public.app_releases IS '应用发布版本表';
COMMENT ON COLUMN public.app_releases.version IS '版本号';
COMMENT ON COLUMN public.app_releases.platform IS '平台标识 (ios/android/windows/macos/linux)';
COMMENT ON COLUMN public.app_releases.variant IS '变体/架构标识 (x64/x86/arm64/intel/m/deb/rpm/appimage/snap/flatpak/aur)';
COMMENT ON COLUMN public.app_releases.file_url IS '安装包下载地址';
COMMENT ON COLUMN public.app_releases.file_size IS '文件大小（字节）';
COMMENT ON COLUMN public.app_releases.release_notes IS '更新日志/版本说明';
COMMENT ON COLUMN public.app_releases.is_active IS '是否启用';
COMMENT ON COLUMN public.app_releases.is_mandatory IS '是否强制更新';
-- =============================================================================
-- 3. 创建索引 (加速查询)
-- =============================================================================
-- 按平台和版本查询
CREATE INDEX IF NOT EXISTS idx_releases_platform_version
ON public.app_releases(platform, version DESC);
-- 按平台和激活状态查询
CREATE INDEX IF NOT EXISTS idx_releases_platform_active
ON public.app_releases(platform, is_active, created_at DESC);
-- =============================================================================
-- 4. 启用 RLS (行级安全策略)
-- =============================================================================
ALTER TABLE public.app_releases ENABLE ROW LEVEL SECURITY;
-- 策略 A: 允许所有人 (Public) "读取" 激活的发布版本
CREATE POLICY "Public can view active releases"
ON public.app_releases FOR SELECT
USING ( is_active = true );
-- 策略 B: Service Role 自动拥有所有权限，无需额外配置
-- =============================================================================
-- 5. 创建 releases Storage 存储桶
-- =============================================================================
INSERT INTO storage.buckets (id, name, public)
VALUES ('releases', 'releases', true)
ON CONFLICT (id) DO NOTHING;
-- 允许所有人读取 'releases' 桶里的文件 (用于下载)
CREATE POLICY "Public Access for Releases"
ON storage.objects FOR SELECT
USING ( bucket_id = 'releases' );
-- 允许已登录用户上传文件
CREATE POLICY "Authenticated users can upload releases"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'releases' );
-- =============================================================================
-- 6. 创建更新时间触发器
-- =============================================================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER update_app_releases_updated_at
  BEFORE UPDATE ON public.app_releases
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
-- =============================================================================
-- 社交链接/专业产品 管理表 (social_links)
-- 用于管理侧边栏折叠后显示的小方块链接
-- =============================================================================
create table if not exists public.social_links (
  id uuid default gen_random_uuid() primary key,
  -- 基础信息
  title text not null,                -- 标题 (悬浮显示)
  description text,                   -- 描述 (悬浮显示)
  icon_url text not null,             -- 图标 URL (图片)
  target_url text not null,           -- 点击跳转链接
  -- 控制开关
  is_active boolean default true,     -- 上下架状态
  sort_order int default 0,           -- 排序顺序 (数字越小越靠前)
  -- 文件信息
  file_size bigint,                   -- 图标文件大小 (字节)
  -- 审计时间
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
-- =============================================================================
-- 创建索引 (加速查询)
-- =============================================================================
create index if not exists idx_social_links_active_order
on public.social_links(is_active, sort_order asc);
-- =============================================================================
-- 启用 RLS (行级安全策略)
-- =============================================================================
alter table public.social_links enable row level security;
-- 策略 A: 允许所有人 "读取" 活跃的社交链接
create policy "Public can view active social links"
on public.social_links for select
using ( is_active = true );
-- =============================================================================
-- 创建 Storage 存储桶 (用于存储社交链接图标)
-- =============================================================================
-- 创建一个叫 'social-icons' 的公共桶
insert into storage.buckets (id, name, public)
values ('social-icons', 'social-icons', true)
on conflict (id) do nothing;
-- 删除可能已存在的策略（避免冲突）
drop policy if exists "Public Access Social Icons" on storage.objects;
drop policy if exists "Authenticated users can upload social icons" on storage.objects;
-- 允许所有人读取 'social-icons' 桶里的图标 (用于前端展示)
create policy "Public Access Social Icons"
on storage.objects for select
using ( bucket_id = 'social-icons' );
-- 允许已登录用户上传图标
create policy "Authenticated users can upload social icons"
on storage.objects for insert
to authenticated
with check ( bucket_id = 'social-icons' );
-- =============================================================================
-- 创建更新时间触发器
-- =============================================================================
create or replace function update_social_links_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;
drop trigger if exists trigger_social_links_updated_at on public.social_links;
create trigger trigger_social_links_updated_at
before update on public.social_links
for each row
execute function update_social_links_updated_at();
-- =============================================================================
-- MornGPT Expert Chat Logs (17 tables)
-- 每个专家模型一张表，用于收集对话数据（用户ID、提问/时间、回复/时间）。
-- =============================================================================
create extension if not exists "pgcrypto";
-- A: Growth Advisory
create table if not exists public.mgx_a_growth_advisory (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_a_growth_advisory_user_id
on public.mgx_a_growth_advisory(user_id);
alter table public.mgx_a_growth_advisory enable row level security;
-- B: Interview/Job
create table if not exists public.mgx_b_interview_job (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_b_interview_job_user_id
on public.mgx_b_interview_job(user_id);
alter table public.mgx_b_interview_job enable row level security;
-- C: AI Coder
create table if not exists public.mgx_c_ai_coder (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_c_ai_coder_user_id
on public.mgx_c_ai_coder(user_id);
alter table public.mgx_c_ai_coder enable row level security;
-- D: Content Detection
create table if not exists public.mgx_d_content_detection (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_d_content_detection_user_id
on public.mgx_d_content_detection(user_id);
alter table public.mgx_d_content_detection enable row level security;
-- E: Medical Advice
create table if not exists public.mgx_e_medical_advice (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_e_medical_advice_user_id
on public.mgx_e_medical_advice(user_id);
alter table public.mgx_e_medical_advice enable row level security;
-- H: Multi-GPT
create table if not exists public.mgx_h_multi_gpt (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_h_multi_gpt_user_id
on public.mgx_h_multi_gpt(user_id);
alter table public.mgx_h_multi_gpt enable row level security;
-- L: AI Lawyer
create table if not exists public.mgx_l_ai_lawyer (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_l_ai_lawyer_user_id
on public.mgx_l_ai_lawyer(user_id);
alter table public.mgx_l_ai_lawyer enable row level security;
-- N: Entertainment Advisor
create table if not exists public.mgx_n_entertainment_advisor (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_n_entertainment_advisor_user_id
on public.mgx_n_entertainment_advisor(user_id);
alter table public.mgx_n_entertainment_advisor enable row level security;
-- O: Housing
create table if not exists public.mgx_o_housing (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_o_housing_user_id
on public.mgx_o_housing(user_id);
alter table public.mgx_o_housing enable row level security;
-- P: Person Matching
create table if not exists public.mgx_p_person_matching (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_p_person_matching_user_id
on public.mgx_p_person_matching(user_id);
alter table public.mgx_p_person_matching enable row level security;
-- Q: AI Teacher
create table if not exists public.mgx_q_ai_teacher (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_q_ai_teacher_user_id
on public.mgx_q_ai_teacher(user_id);
alter table public.mgx_q_ai_teacher enable row level security;
-- R: Travel Planning
create table if not exists public.mgx_r_travel_planning (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_r_travel_planning_user_id
on public.mgx_r_travel_planning(user_id);
alter table public.mgx_r_travel_planning enable row level security;
-- S: Product Search
create table if not exists public.mgx_s_product_search (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_s_product_search_user_id
on public.mgx_s_product_search(user_id);
alter table public.mgx_s_product_search enable row level security;
-- T: Fashion
create table if not exists public.mgx_t_fashion (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_t_fashion_user_id
on public.mgx_t_fashion(user_id);
alter table public.mgx_t_fashion enable row level security;
-- U: Food & Dining
create table if not exists public.mgx_u_food_dining (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_u_food_dining_user_id
on public.mgx_u_food_dining(user_id);
alter table public.mgx_u_food_dining enable row level security;
-- W: Content Generation
create table if not exists public.mgx_w_content_generation (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_w_content_generation_user_id
on public.mgx_w_content_generation(user_id);
alter table public.mgx_w_content_generation enable row level security;
-- Z: AI Protection
create table if not exists public.mgx_z_ai_protection (
  id uuid default gen_random_uuid() primary key,
  user_id uuid not null references auth.users on delete cascade,
  user_message text not null,
  user_message_at timestamptz not null,
  assistant_message text not null,
  assistant_message_at timestamptz not null,
  model_id text not null,
  created_at timestamptz default now()
);
create index if not exists idx_mgx_z_ai_protection_user_id
on public.mgx_z_ai_protection(user_id);
alter table public.mgx_z_ai_protection enable row level security;
-- Ensure service_role has access
grant all privileges on all tables in schema public to postgres, service_role;
-- =============================================================================
-- Conversations: persist model type + expert id for folder grouping
-- Folder keys: General / MornGPT / External (derived from model_type)
-- =============================================================================
alter table public.conversations
  add column if not exists model_type text;
alter table public.conversations
  add column if not exists expert_model_id text;
create index if not exists idx_conversations_model_type
  on public.conversations(model_type);
create index if not exists idx_conversations_expert_model_id
  on public.conversations(expert_model_id);
import type { Config } from "tailwindcss";
// all in fixtures is set to tailwind v3 as interims solutions
const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./constants/**/*.{js,ts,jsx,tsx}",
    "./features/**/*.{js,ts,jsx,tsx,mdx}",
    "*.{js,ts,jsx,tsx,mdx}"
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "target": "ES6",
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next-build/types/**/*.ts",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "nextdist/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
// Speech Recognition types
export interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  maxAlternatives: number;
  start(): void;
  stop(): void;
  abort(): void;
  onresult:
    | ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any)
    | null;
  onerror:
    | ((this: SpeechRecognition, ev: SpeechRecognitionErrorEvent) => any)
    | null;
  onend: ((this: SpeechRecognition, ev: Event) => any) | null;
}
export interface SpeechRecognitionEvent extends Event {
  resultIndex: number;
  results: SpeechRecognitionResultList;
}
export interface SpeechRecognitionResultList {
  length: number;
  item(index: number): SpeechRecognitionResult;
  [index: number]: SpeechRecognitionResult;
}
export interface SpeechRecognitionResult {
  isFinal: boolean;
  length: number;
  item(index: number): SpeechRecognitionAlternative;
  [index: number]: SpeechRecognitionAlternative;
}
export interface SpeechRecognitionAlternative {
  transcript: string;
  confidence: number;
}
export interface SpeechRecognitionErrorEvent extends Event {
  error: string;
  message: string;
}
declare global {
  interface Window {
    SpeechRecognition: new () => SpeechRecognition;
    webkitSpeechRecognition: new () => SpeechRecognition;
  }
}
export interface Message {
  id: string;
  role: "user" | "assistant" | "system";
  content: string;
  timestamp: Date;
  model?: string;
  isMultiGPT?: boolean;
  isStreaming?: boolean;
  subTasks?: Array<{
    task: string;
    model: string;
    response: string;
  }>;
  images?: string[];
  videos?: string[];
  imagePreviews?: string[];
  videoPreviews?: string[];
  audios?: string[];
  audioPreviews?: string[];
}
// Generic attachment item used by the chat input & upload pipeline
export interface AttachmentItem {
  id: string;
  name: string;
  size: number;
  type: string;
  kind: "image" | "video" | "audio" | "file";
  file?: File;
  preview?: string;
  fileId?: string; // CloudBase fileID after upload
  format?: string;
}
export interface ChatSession {
  id: string;
  title: string;
  messages: Message[];
  model: string;
  modelType: string;
  category: string;
  lastUpdated: Date;
  isModelLocked: boolean;
}
// 钱包结构（国内版配额统一入口）
export interface UserWallet {
  // 月度配额（随订阅或免费额度重置）
  monthly_image_balance: number;
  monthly_video_balance: number;
  monthly_reset_at?: string;
  // 加油包配额（永久有效）
  addon_image_balance: number;
  addon_video_balance: number;
  // 外部模型每日用量（按天重置）
  daily_external_used?: number;
  daily_external_day?: string;
}
export interface AppUser {
  id: string;
  email: string;
  name: string;
  bio?: string;
  isPro: boolean;
  isPaid: boolean;
  plan?: "Basic" | "Pro" | "Enterprise";
  planExp?: string;
  avatar?: string;
  wallet?: UserWallet;
  pendingDowngrade?: {
    targetPlan: "Basic" | "Pro" | "Enterprise";
    effectiveAt?: string;
  } | null;
  settings?: {
    theme: "light" | "dark" | "auto";
    language: string;
    notifications: boolean;
    soundEnabled: boolean;
    autoSave: boolean;
    sendHotkey?: "enter" | "shift+enter" | "ctrl+enter" | "cmd+enter";
    shortcutsEnabled?: boolean;
    adsEnabled?: boolean;
    hideAds?: boolean; // 订阅用户是否开启去除广告功能
  };
}
export interface BookmarkedMessage {
  id: string;
  messageId: string;
  chatId: string;
  title: string;
  content: string;
  timestamp: Date;
  customName?: string;
  folder?: string;
}
export interface BookmarkFolder {
  id: string;
  name: string;
  color?: string;
  createdAt: Date;
}
export interface ExternalModel {
  id: string;
  name: string;
  provider: string;
  description: string;
  category: string;
  modality?: "multimodal" | "text";
  type: "free" | "premium" | "popular" | "paid";
  price: string;
}
export interface UserSettings {
  theme: "light" | "dark" | "auto";
  language: string;
  notifications: boolean;
  soundEnabled: boolean;
  autoSave: boolean;
  sendHotkey?: "enter" | "shift+enter" | "ctrl+enter" | "cmd+enter";
  shortcutsEnabled?: boolean;
  adsEnabled?: boolean;
  hideAds?: boolean; // 订阅用户是否开启去除广告功能
}
// Re-export all utilities from lib/utils for backward compatibility
export {
  cn,
  containsChinese,
  detectLanguage,
  autoDetectLanguage,
  formatFileSize,
  getFileIcon,
  copyToClipboard,
  shareMessage,
  downloadMessage,
  getSelectedModelDisplay,
} from "../lib/utils";
// Re-export model limits utilities
export * from "./model-limits";
/**
 * 模型分类与配额限制工具
 * 用于国内版 Free 用户的分级配额策略
 */
// =============================================================================
// 模型分类定义
// =============================================================================
import { IS_DOMESTIC_VERSION } from "@/config";
// 默认通用模型（前端展示为 General Model）：
// - 国内版使用 Qwen-Turbo
// - 国际版使用 Mistral-small-latest
export const GENERAL_MODEL_ID = IS_DOMESTIC_VERSION ? "qwen-turbo" : "mistral-small-latest";
/**
 * 通用模型列表 (General/Internal Models)
 * 这些模型对 Free 用户无限制使用
 */
export const GENERAL_MODELS = [GENERAL_MODEL_ID];
/**
 * 外部模型列表 (External Models)
 * 这些模型受每日配额限制
 */
export const EXTERNAL_MODELS = [
  // 国内版模型
  "qwen3-max",
  "qwen-plus",
  "qwen-flash",
  "qwen3-coder-plus",
  "qwen3-coder-flash",
  "deepseek-r1",
  "deepseek-v3",
  "deepseek-v3.1",
  "deepseek-v3.2-exp",
  "Moonshot-Kimi-K2-Instruct",
  "glm-4.6",
  // 国际版模型 (Mistral)
  "codestral-latest",
  "codestral-2412",
  "mistral-medium-latest",
];
/**
 * 高级多模态模型列表 (Advanced Multimodal Models)
 * 这些模型受每月媒体配额限制
 */
export const ADVANCED_MULTIMODAL_MODELS = [
  "qwen3-omni-flash",
];
// =============================================================================
// 模型分类判断函数
// =============================================================================
/**
 * 判断是否为通用模型 (无限制)
 */
export function isGeneralModel(modelId: string): boolean {
  return GENERAL_MODELS.some(
    (m) => m.toLowerCase() === modelId.toLowerCase()
  );
}
/**
 * 判断是否为外部模型 (每日配额限制)
 */
export function isExternalModel(modelId: string): boolean {
  return EXTERNAL_MODELS.some(
    (m) => m.toLowerCase() === modelId.toLowerCase()
  );
}
/**
 * 判断是否为高级多模态模型 (每月媒体配额限制)
 */
export function isAdvancedMultimodalModel(modelId: string): boolean {
  return ADVANCED_MULTIMODAL_MODELS.some(
    (m) => m.toLowerCase() === modelId.toLowerCase()
  );
}
/**
 * 获取模型分类类型
 */
export type ModelCategory = "general" | "external" | "advanced_multimodal" | "unknown";
export function getModelCategory(modelId: string): ModelCategory {
  if (isGeneralModel(modelId)) return "general";
  if (isExternalModel(modelId)) return "external";
  if (isAdvancedMultimodalModel(modelId)) return "advanced_multimodal";
  return "unknown";
}
// =============================================================================
// 配额限制常量获取
// =============================================================================
/**
 * 获取外部模型每日限制
 */
export function getFreeDailyLimit(): number {
  const raw = process.env.NEXT_PUBLIC_FREE_DAILY_LIMIT || "10";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 10;
  return Math.min(1000, n);
}
/**
 * 获取 Basic 订阅每日外部模型限制
 */
export function getBasicDailyLimit(): number {
  const raw = process.env.NEXT_PUBLIC_BASIC_DAILY_LIMIT || "100";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 100;
  return Math.min(10000, n);
}
/**
 * 获取 Pro 订阅每日外部模型限制
 */
export function getProDailyLimit(): number {
  const raw = process.env.NEXT_PUBLIC_PRO_DAILY_LIMIT || "200";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 200;
  return Math.min(20000, n);
}
/**
 * 获取高级多模态模型每月图片限制
 */
export function getFreeMonthlyPhotoLimit(): number {
  const raw = process.env.NEXT_PUBLIC_FREE_MONTHLY_PHOTO_LIMIT || "30";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 30;
  return Math.min(10000, n);
}
/**
 * 获取高级多模态模型每月视频/音频限制
 */
export function getFreeMonthlyVideoAudioLimit(): number {
  const raw = process.env.NEXT_PUBLIC_FREE_MONTHLY_VIDEO_AUDIO_LIMIT || "5";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 5;
  return Math.min(1000, n);
}
/**
 * 获取 Basic 订阅多模态图片月度限制
 */
export function getBasicMonthlyPhotoLimit(): number {
  const raw = process.env.NEXT_PUBLIC_BASIC_MONTHLY_PHOTO_LIMIT || "100";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 100;
  return Math.min(10000, n);
}
/**
 * 获取 Pro 订阅多模态图片月度限制
 */
export function getProMonthlyPhotoLimit(): number {
  const raw = process.env.NEXT_PUBLIC_PRO_MONTHLY_PHOTO_LIMIT || "500";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 500;
  return Math.min(20000, n);
}
/**
 * 获取 Basic 订阅多模态视频/音频月度限制
 */
export function getBasicMonthlyVideoAudioLimit(): number {
  const raw = process.env.NEXT_PUBLIC_BASIC_MONTHLY_VIDEO_AUDIO_LIMIT || "20";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 20;
  return Math.min(1000, n);
}
/**
 * 获取 Pro 订阅多模态视频/音频月度限制
 */
export function getProMonthlyVideoAudioLimit(): number {
  const raw = process.env.NEXT_PUBLIC_PRO_MONTHLY_VIDEO_AUDIO_LIMIT || "100";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 100;
  return Math.min(5000, n);
}
/**
 * 获取 Enterprise 订阅每日外部模型限制
 */
export function getEnterpriseDailyLimit(): number {
  const raw = process.env.NEXT_PUBLIC_ENTERPRISE_DAILY_LIMIT || "500";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 500;
  return Math.min(50000, n);
}
/**
 * 获取 Enterprise 订阅多模态图片月度限制
 */
export function getEnterpriseMonthlyPhotoLimit(): number {
  const raw = process.env.NEXT_PUBLIC_ENTERPRISE_MONTHLY_PHOTO_LIMIT || "1000";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 1000;
  return Math.min(50000, n);
}
/**
 * 获取 Enterprise 订阅多模态视频/音频月度限制
 */
export function getEnterpriseMonthlyVideoAudioLimit(): number {
  const raw = process.env.NEXT_PUBLIC_ENTERPRISE_MONTHLY_VIDEO_AUDIO_LIMIT || "200";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 200;
  return Math.min(20000, n);
}
/**
 * 获取 Free 用户上下文消息限制 (非消耗型，仅用于截断历史)
 */
export function getFreeContextMsgLimit(): number {
  const raw = process.env.NEXT_PUBLIC_FREE_CONTEXT_MSG_LIMIT || "10";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 10;
  return Math.min(100, n);
}
/**
 * 获取 Basic 用户上下文消息限制 (非消耗型，仅用于截断历史)
 */
export function getBasicContextMsgLimit(): number {
  const raw = process.env.NEXT_PUBLIC_BASIC_CONTEXT_MSG_LIMIT || "50";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 50;
  return Math.min(200, n);
}
/**
 * 获取 Pro 用户上下文消息限制 (非消耗型，仅用于截断历史)
 */
export function getProContextMsgLimit(): number {
  const raw =
    process.env.NEXT_PUBLIC_PRO_CONTEXT_MSG_LIMIT ||
    process.env.NEXT_PUBLIC_Pro_CONTEXT_MSG_LIMIT ||
    "100";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 100;
  return Math.min(300, n);
}
/**
 * 获取 Enterprise 用户上下文消息限制 (非消耗型，仅用于截断历史)
 */
export function getEnterpriseContextMsgLimit(): number {
  const raw =
    process.env.NEXT_PUBLIC_ENTERPRISE_CONTEXT_MSG_LIMIT ||
    process.env.NEXT_PUBLIC_Enterprise_CONTEXT_MSG_LIMIT ||
    "200";
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n <= 0) return 200;
  return Math.min(500, n);
}
// =============================================================================
// 媒体类型检测
// =============================================================================
export interface MediaPayload {
  images?: string[];
  videos?: string[];
  audios?: string[];
}
/**
 * 检测请求中是否包含图片
 */
export function hasImages(payload: MediaPayload): boolean {
  return Array.isArray(payload.images) && payload.images.length > 0;
}
/**
 * 检测请求中是否包含视频或音频
 */
export function hasVideoOrAudio(payload: MediaPayload): boolean {
  const hasVideo = Array.isArray(payload.videos) && payload.videos.length > 0;
  const hasAudio = Array.isArray(payload.audios) && payload.audios.length > 0;
  return hasVideo || hasAudio;
}
/**
 * 获取图片数量
 */
export function getImageCount(payload: MediaPayload): number {
  return Array.isArray(payload.images) ? payload.images.length : 0;
}
/**
 * 获取视频/音频数量 (合并计算)
 */
export function getVideoAudioCount(payload: MediaPayload): number {
  const videoCount = Array.isArray(payload.videos) ? payload.videos.length : 0;
  const audioCount = Array.isArray(payload.audios) ? payload.audios.length : 0;
  return videoCount + audioCount;
}
// =============================================================================
// 配额检查结果类型
// =============================================================================
export interface QuotaCheckResult {
  allowed: boolean;
  reason?: string;
  quotaType?: "unlimited" | "daily" | "monthly_photo" | "monthly_video_audio";
  remaining?: number;
  limit?: number;
}
/**
 * 生成配额不足的错误消息
 */
export function getQuotaExceededMessage(
  quotaType: string,
  language: string = "zh"
): string {
  const isZh = language === "zh";
  switch (quotaType) {
    case "daily":
      return isZh
        ? "今日外部模型配额已用完，请升级套餐或明天再试，或切换到通用模型（General Model）继续使用。"
        : "Daily external model quota exceeded. Please upgrade your plan, try again tomorrow, or switch to the General Model.";
    case "monthly_photo":
      return isZh
        ? "本月图片配额已用完，请升级套餐或下月再试。"
        : "Monthly photo quota exceeded. Please upgrade your plan or try again next month.";
    case "monthly_video_audio":
      return isZh
        ? "本月视频/音频配额已用完，请升级套餐或下月再试。"
        : "Monthly video/audio quota exceeded. Please upgrade your plan or try again next month.";
    default:
      return isZh
        ? "配额已用完，请升级套餐继续使用。"
        : "Quota exceeded. Please upgrade your plan to continue.";
  }
}
/**
 * 获取上下文截断提示消息
 */
export function getContextTruncationMessage(
  limit: number,
  language: string = "zh"
): string {
  const isZh = language === "zh";
  return isZh
    ? `已仅保留最近 ${limit} 条消息作为上下文记忆。`
    : `Only the most recent ${limit} messages are kept as context memory.`;
}
// =============================================================================
// 日期工具函数
// =============================================================================
/**
 * 获取今天的日期字符串 (YYYY-MM-DD) - 北京时间
 */
export function getTodayString(): string {
  const now = new Date();
  const utc = now.getTime() + now.getTimezoneOffset() * 60000;
  const beijing = new Date(utc + 8 * 3600000);
  return beijing.toISOString().split("T")[0];
}
/**
 * 获取当月第一天的日期字符串 (YYYY-MM-DD) - 北京时间
 */
export function getMonthStartString(): string {
  const now = new Date();
  const utc = now.getTime() + now.getTimezoneOffset() * 60000;
  const beijing = new Date(utc + 8 * 3600000);
  const monthStart = new Date(beijing.getFullYear(), beijing.getMonth(), 1);
  return monthStart.toISOString().split("T")[0];
}
/**
 * 获取当前年月字符串 (YYYY-MM) - 北京时间
 */
export function getCurrentYearMonth(): string {
  const now = new Date();
  const utc = now.getTime() + now.getTimezoneOffset() * 60000;
  const beijing = new Date(utc + 8 * 3600000);
  return `${beijing.getFullYear()}-${String(beijing.getMonth() + 1).padStart(2, "0")}`;
}
/**
 * 密码工具函数
 * 使用 bcryptjs 进行密码哈希和验证
 */
import bcrypt from "bcryptjs";
const SALT_ROUNDS = 12;
/**
 * 生成密码哈希
 * @param password 明文密码
 * @returns 哈希后的密码
 */
export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}
/**
 * 验证密码
 * @param password 明文密码
 * @param hash 数据库中的哈希值
 * @returns 是否匹配
 */
export async function verifyPassword(
  password: string,
  hash: string
): Promise<boolean> {
  return bcrypt.compare(password, hash);
}
// 统一的配额请求去重工具，避免多处组件同时轮询
const inFlight: Record<string, Promise<any> | null> = {};
const lastData: Record<string, any> = {};
const lastTs: Record<string, number> = {};
const TTL_MS = 1000; // 1 秒内重复请求直接复用
export async function fetchQuotaShared(url: string = "/api/account/quota") {
  const now = Date.now();
  if (lastTs[url] && now - lastTs[url] < TTL_MS && lastData[url]) {
    return lastData[url];
  }
  if (inFlight[url]) {
    return inFlight[url] as Promise<any>;
  }
  inFlight[url] = (async () => {
    try {
      const res = await fetch(url, { credentials: "include" });
      if (!res.ok) {
        throw new Error(`quota fetch failed ${res.status}`);
      }
      const data = await res.json();
      lastData[url] = data;
      lastTs[url] = Date.now();
      return data;
    } finally {
      inFlight[url] = null;
    }
  })();
  return inFlight[url] as Promise<any>;
}
/**
 * Session 管理工具
 * 基于 HttpOnly Cookie 实现管理员会话管理
 */
import { cookies } from "next/headers";
// Session 配置
const SESSION_COOKIE_NAME = "admin_session";
const SESSION_MAX_AGE = 60 * 60 * 24; // 24小时
// 简单加密密钥（生产环境建议使用环境变量）
const SECRET_KEY = process.env.ADMIN_SESSION_SECRET || "admin-secret-key-change-in-production";
export interface AdminSession {
  userId: string;
  username: string;
  createdAt: number;
  expiresAt: number;
}
/**
 * 简单的 Base64 编码/解码加密
 * 生产环境建议使用更强的加密方案如 jose/jwt
 */
function encryptSession(session: AdminSession): string {
  const payload = JSON.stringify(session);
  const encoded = Buffer.from(payload).toString("base64");
  // 添加简单签名
  const signature = Buffer.from(
    `${encoded}.${SECRET_KEY}`
  ).toString("base64");
  return `${encoded}.${signature.slice(0, 16)}`;
}
function decryptSession(token: string): AdminSession | null {
  try {
    const [encoded, sig] = token.split(".");
    if (!encoded || !sig) return null;
    // 验证签名
    const expectedSig = Buffer.from(
      `${encoded}.${SECRET_KEY}`
    ).toString("base64").slice(0, 16);
    if (sig !== expectedSig) return null;
    const payload = Buffer.from(encoded, "base64").toString("utf-8");
    return JSON.parse(payload) as AdminSession;
  } catch {
    return null;
  }
}
/**
 * 创建管理员会话
 */
export async function createAdminSession(
  userId: string,
  username: string
): Promise<void> {
  const now = Date.now();
  const session: AdminSession = {
    userId,
    username,
    createdAt: now,
    expiresAt: now + SESSION_MAX_AGE * 1000,
  };
  const token = encryptSession(session);
  const cookieStore = await cookies();
  cookieStore.set(SESSION_COOKIE_NAME, token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: SESSION_MAX_AGE,
    path: "/",
  });
}
/**
 * 获取当前管理员会话
 */
export async function getAdminSession(): Promise<AdminSession | null> {
  const cookieStore = await cookies();
  const token = cookieStore.get(SESSION_COOKIE_NAME)?.value;
  if (!token) return null;
  const session = decryptSession(token);
  if (!session) return null;
  // 检查是否过期
  if (Date.now() > session.expiresAt) {
    await destroyAdminSession();
    return null;
  }
  return session;
}
/**
 * 验证管理员会话是否有效
 */
export async function verifyAdminSession(): Promise<boolean> {
  const session = await getAdminSession();
  return session !== null;
}
/**
 * 销毁管理员会话（登出）
 */
export async function destroyAdminSession(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.delete(SESSION_COOKIE_NAME);
}
/**
 * 刷新会话（延长过期时间）
 */
export async function refreshAdminSession(): Promise<void> {
  const session = await getAdminSession();
  if (session) {
    await createAdminSession(session.userId, session.username);
  }
}
=============== 后 30 页代码结束 ===============